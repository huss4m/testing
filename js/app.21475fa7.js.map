{"version":3,"file":"js/app.21475fa7.js","mappings":"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","sources":["webpack://b101/./src/App.vue?49f4","webpack://b101/./src/App.vue","webpack://b101/./src/components/Savior.vue?2ddd","webpack://b101/./src/components/Savior.vue","webpack://b101/./src/Savior/Enemy.ts","webpack://b101/./src/Savior/Mutant.ts","webpack://b101/./src/Savior/WeaponPickups.ts","webpack://b101/./src/Savior/AmmoPickup.ts","webpack://b101/./src/Savior/FirstAidPickup.ts","webpack://b101/./src/Savior/Warrok.ts","webpack://b101/./src/Savior/SkeletonZombie.ts","webpack://b101/./src/Savior/Boss.ts","webpack://b101/./src/Savior/TorchPowerup.ts","webpack://b101/./src/Savior/MedalPowerup.ts","webpack://b101/./src/Savior/Instances.ts","webpack://b101/./src/Savior/Level.ts","webpack://b101/./src/Savior/Weapon.ts","webpack://b101/./src/Savior/Player.ts","webpack://b101/./src/Savior/UI.ts","webpack://b101/./src/Savior/M60.ts","webpack://b101/./src/Savior/Pistol.ts","webpack://b101/./src/Savior/Minigun.ts","webpack://b101/./src/Savior/FirstPersonController.ts","webpack://b101/./src/Savior/MainMenu.ts","webpack://b101/./src/components/Savior.vue?dae2","webpack://b101/./src/App.vue?7ccd","webpack://b101/./src/main.ts","webpack://b101/webpack/bootstrap","webpack://b101/webpack/runtime/chunk loaded","webpack://b101/webpack/runtime/define property getters","webpack://b101/webpack/runtime/global","webpack://b101/webpack/runtime/hasOwnProperty shorthand","webpack://b101/webpack/runtime/publicPath","webpack://b101/webpack/runtime/jsonp chunk loading","webpack://b101/webpack/startup"],"sourcesContent":["import { resolveComponent as _resolveComponent, openBlock as _openBlock, createBlock as _createBlock } from \"vue\"\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  const _component_Savior = _resolveComponent(\"Savior\")!\n\n  return (_openBlock(), _createBlock(_component_Savior))\n}","<template>\n  \n  <Savior />\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue';\nimport Savior from './components/Savior.vue';\n\nexport default defineComponent({\n  name: 'App',\n  components: {\n    Savior\n  }\n});\n</script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n /*  margin-top: 60px; */\n}\n</style>\n","import { createElementVNode as _createElementVNode, createTextVNode as _createTextVNode, createStaticVNode as _createStaticVNode, openBlock as _openBlock, createElementBlock as _createElementBlock, pushScopeId as _pushScopeId, popScopeId as _popScopeId } from \"vue\"\nimport _imports_0 from '@/assets/saviorlogo.png'\nimport _imports_1 from '@/assets/olympiclogo.png'\n\n\nconst _withScopeId = n => (_pushScopeId(\"data-v-036e46e7\"),n=n(),_popScopeId(),n)\nconst _hoisted_1 = /*#__PURE__*/_createStaticVNode(\"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" data-v-036e46e7><div class=\\\"banner\\\" data-v-036e46e7><div class=\\\"logo-container\\\" data-v-036e46e7><img src=\\\"\" + _imports_0 + \"\\\" id=\\\"saviorlogo\\\" data-v-036e46e7><img src=\\\"\" + _imports_1 + \"\\\" id=\\\"olympicLogo\\\" data-v-036e46e7></div></div>\", 2)\nconst _hoisted_3 = { ref: \"canvas\" }\nconst _hoisted_4 = /*#__PURE__*/_createStaticVNode(\"<footer class=\\\"footer\\\" data-v-036e46e7><p class=\\\"footer-text\\\" data-v-036e46e7>Credits: First person weapon models by <a href=\\\"https://sketchfab.com/bumstrum\\\" target=\\\"_blank\\\" class=\\\"credit-link\\\" data-v-036e46e7>3DMaesen (bumstrum)</a> under <a href=\\\"https://creativecommons.org/licenses/by/4.0/\\\" target=\\\"_blank\\\" class=\\\"license-link\\\" data-v-036e46e7>CC BY 4.0</a> (CC Attribution License).</p><p class=\\\"footer-text\\\" data-v-036e46e7> Torch model <a href=\\\"https://sketchfab.com/leondp\\\" target=\\\"_blank\\\" class=\\\"credit-link\\\" data-v-036e46e7>Nortenko Dmytro</a> under <a href=\\\"https://creativecommons.org/licenses/by/4.0/\\\" target=\\\"_blank\\\" class=\\\"license-link\\\" data-v-036e46e7>CC BY 4.0</a> (CC Attribution License).</p><p class=\\\"footer-text\\\" data-v-036e46e7> Olympic medal <a href=\\\"https://sketchfab.com/AlbertoLuviano\\\" target=\\\"_blank\\\" class=\\\"credit-link\\\" data-v-036e46e7>Alberto Luviano</a> under <a href=\\\"https://creativecommons.org/licenses/by/4.0/\\\" target=\\\"_blank\\\" class=\\\"license-link\\\" data-v-036e46e7>CC BY 4.0</a> (CC Attribution License).</p><p class=\\\"footer-text\\\" data-v-036e46e7> Health kit <a href=\\\"https://sketchfab.com/stefanocagnani1990\\\" target=\\\"_blank\\\" class=\\\"credit-link\\\" data-v-036e46e7>Stefano Cagnani</a> under <a href=\\\"https://creativecommons.org/licenses/by/4.0/\\\" target=\\\"_blank\\\" class=\\\"license-link\\\" data-v-036e46e7>CC BY 4.0</a> (CC Attribution License).</p><p class=\\\"footer-text\\\" data-v-036e46e7>Credit to <a href=\\\"https://www.FesliyanStudios.com\\\" target=\\\"_blank\\\" class=\\\"credit-link\\\" data-v-036e46e7>FesliyanStudios</a> for the background music </p></footer>\", 1)\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  return (_openBlock(), _createElementBlock(\"div\", null, [\n    _hoisted_1,\n    _createElementVNode(\"canvas\", _hoisted_3, null, 512),\n    _hoisted_4\n  ]))\n}","<template>\n  <div>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    \n    <div class=\"banner\">\n      <div class=\"logo-container\">\n        <img src=\"@/assets/saviorlogo.png\" id=\"saviorlogo\" />\n        <img src=\"@/assets/olympiclogo.png\" id=\"olympicLogo\" />\n      </div>\n    </div>\n\n    <canvas ref=\"canvas\"></canvas>\n\n    <footer class=\"footer\">\n      <p class=\"footer-text\">Credits: First person weapon models by <a href=\"https://sketchfab.com/bumstrum\" target=\"_blank\" class=\"credit-link\">3DMaesen (bumstrum)</a> under <a href=\"https://creativecommons.org/licenses/by/4.0/\" target=\"_blank\" class=\"license-link\">CC BY 4.0</a> (CC Attribution License).</p>\n      <p class=\"footer-text\"> Torch model <a href=\"https://sketchfab.com/leondp\" target=\"_blank\" class=\"credit-link\">Nortenko Dmytro</a> under <a href=\"https://creativecommons.org/licenses/by/4.0/\" target=\"_blank\" class=\"license-link\">CC BY 4.0</a> (CC Attribution License).</p>\n      <p class=\"footer-text\"> Olympic medal <a href=\"https://sketchfab.com/AlbertoLuviano\" target=\"_blank\" class=\"credit-link\">Alberto Luviano</a> under <a href=\"https://creativecommons.org/licenses/by/4.0/\" target=\"_blank\" class=\"license-link\">CC BY 4.0</a> (CC Attribution License).</p>\n      <p class=\"footer-text\"> Health kit <a href=\"https://sketchfab.com/stefanocagnani1990\" target=\"_blank\" class=\"credit-link\">Stefano Cagnani</a> under <a href=\"https://creativecommons.org/licenses/by/4.0/\" target=\"_blank\" class=\"license-link\">CC BY 4.0</a> (CC Attribution License).</p>\n      \n      <p class =\"footer-text\">Credit to <a href=\"https://www.FesliyanStudios.com\" target=\"_blank\" class=\"credit-link\">FesliyanStudios</a> for the background music </p>\n    </footer>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from 'vue';\nimport { FirstPersonController } from '@/Savior/FirstPersonController';\nimport { MainMenu } from '@/Savior/MainMenu';\n\nexport default defineComponent({\n  name: 'SaviorComponent',\n  mounted() {\n    const canvas = this.$refs.canvas as HTMLCanvasElement;\n    //new FirstPersonController(canvas);\n    const mainMenu = new MainMenu(canvas);\n  }\n});\n</script>\n\n<style scoped>\n canvas {\n    width: 70%;\n    height: 70%;\n    position: relative;\n    /* margin-bottom:20px; */\n  }\n\n  .footer {\n    position: absolute bottom;  \n    margin-top: auto;\n    bottom: 0;\n    width: 100%;\n   \n    text-align: center;\n    background-color: rgba(255, 255, 255, 0.5); \n    padding: 4px;\n    \n  }\n\n  .banner {\n    width: 100%;\n    text-align: center;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    background-color: rgba(255, 255, 255, 0.5); \n  }\n\n  .logo-container {\n    position: relative;\n    display: inline-block;\n  }\n\n  #olympicLogo {\n    width: 70%; \n    height: auto; \n    margin-top: 15%; \n  }\n\n  #saviorlogo {\n    width: 100%; \n    height: auto; \n    position: absolute;\n    top: 0;\n    left: 50%;\n    transform: translateX(-50%);\n  }\n\n\n  .credit-link, .license-link {\n    color: #0a4ca3; \n    text-decoration: none;\n    font-weight: bold;\n  }\n\n  .credit-link:hover, .license-link:hover {\n    text-decoration: underline;\n  }\n\n  .footer-text {\n    font-size: 10px;\n    margin: 2px 0;\n  }\n</style>\n","import { AbstractMesh, Tags, Animation, AnimationGroup, Color3, FreeCamera, Material, Mesh, MeshBuilder, PBRMaterial, Ray, Scene, SceneLoader, Sound, StandardMaterial, Texture, TransformNode, Vector3, Axis } from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\nimport { Player } from \"./Player\";\r\nimport { Level } from \"./Level\";\r\n\r\n\r\nexport class Enemy {\r\n    scene: Scene;\r\n    animationGroups: AnimationGroup[] = [];\r\n    health: number;\r\n    name: string;\r\n    mesh: AbstractMesh | null; // Property to store the mesh\r\n    rootMesh: AbstractMesh | null;\r\n    id: number; // Unique identifier for the enemy\r\n    isDead: boolean;\r\n\r\n    runSpeed!: number;\r\n    walkSpeed!: number;\r\n\r\n    damage!: number;\r\n    attackSpeed!: number;\r\n\r\n    attackSound!: Sound;\r\n\r\n\r\n\r\n    punch!: AnimationGroup;\r\n    run!: AnimationGroup;\r\n    idle!: AnimationGroup;\r\n    death!: AnimationGroup;\r\n    shot!: AnimationGroup;\r\n    walk!: AnimationGroup;\r\n    uppercut!: AnimationGroup;\r\n\r\n\r\n    randPosition!: Vector3;\r\n\r\n\r\n    aggroRange!: number;\r\n\r\n \r\n\r\n    transformNode!: TransformNode;\r\n    enemyCollider!: any;\r\n\r\n    collider: any;\r\n\r\n\r\n    appliesDot: boolean;\r\n    isSpellCasting!: boolean;\r\n\r\n\r\n    isAttacking: boolean;\r\n    isReacting: boolean;\r\n\r\n\r\n    scoreValue!: number;\r\n\r\n    static enemyCount = 0; \r\n    states: { DESTROYED: boolean; FOLLOWING: boolean; ATTACKING: boolean; };\r\n    attackTimer: any;\r\n    level: Level;\r\n   \r\n\r\n    constructor(scene: Scene, level: Level) {\r\n        this.scene = scene;\r\n\r\n     \r\n\r\n        this.level = level;\r\n        this.isSpellCasting = false;\r\n        this.health = 100;\r\n        this.name = \"Monster\";\r\n        this.mesh = null; \r\n        this.rootMesh = null;\r\n        this.isDead = false;\r\n        \r\n        this.appliesDot = false;\r\n        this.id = ++Enemy.enemyCount; \r\n\r\n        this.states = {\r\n            'DESTROYED': false,\r\n            'FOLLOWING': false,\r\n            'ATTACKING': false,\r\n        };\r\n\r\n        this.isAttacking = false;\r\n        this.isReacting = false;\r\n\r\n        this.generateRandomPosition();\r\n\r\n    }\r\n\r\n    async CreateMonster(position: Vector3): Promise<void> {\r\n        \r\n            const { meshes, animationGroups } = await SceneLoader.ImportMeshAsync('', './models/', 'mutant.glb');\r\n    \r\n            \r\n            meshes[1].scaling= new Vector3(2,2,2);\r\n            \r\n            //meshes[0].position = position;\r\n            meshes[1].position = position;\r\n\r\n\r\n            \r\n            this.animationGroups = animationGroups;\r\n\r\n            this.mesh = meshes[1];\r\n            this.rootMesh = meshes[0];\r\n            this.mesh.checkCollisions = true;\r\n\r\n\r\n            Tags.AddTagsTo(this.mesh, \"enemy\");\r\n          \r\n            \r\n            animationGroups[0].stop();\r\n            animationGroups[2].play(true);\r\n\r\n    \r\n\r\n/* \r\n        \r\n        this.enemyCollider = MeshBuilder.CreateBox(\"enemyCollider\", {\r\n                width:1,\r\n                height: 1.7,\r\n                depth: 1\r\n            });\r\n            this.enemyCollider.isPickable = false;\r\n            \r\n           this.enemyCollider.position = this.mesh.position;\r\n           this.enemyCollider.position.y = 1; */\r\n\r\n    }\r\n\r\ndeathAnimation() {\r\n    \r\n    // Ajouter un observateur pour dtecter la fin de l'animation du groupe 3\r\n       this.isDead = true;\r\n\r\n\r\n       this.animationGroups[2].stop();\r\n       this.animationGroups[3].stop();\r\n       this.animationGroups[4].stop();\r\n       this.animationGroups[5].stop();\r\n\r\n           // Une fois que l'animation du groupe 3 est termine, reprendre l'animation du groupe 1\r\n           this.animationGroups[1].start(false);\r\n this.animationGroups[1].onAnimationEndObservable.addOnce(() => {\r\n   \r\n    this.animationGroups[1].pause();\r\n}\r\n );\r\n \r\n\r\n    console.log(\"WARROK DEAD\");\r\n    \r\n}\r\n\r\nidleAnimation() {\r\n    console.log(\"IDLE\");\r\n}\r\n\r\nshotAnimation() {\r\n\r\n    this.animationGroups[5].play(false);\r\n // Ajouter un observateur pour dtecter la fin de l'animation du groupe 3\r\n    this.animationGroups[5].onAnimationEndObservable.addOnce(() => {\r\n        // Une fois que l'animation du groupe 3 est termine, reprendre l'animation du groupe 1\r\n        this.animationGroups[2].start(true);\r\n    });\r\n\r\n\r\n    console.log(\"WARROK SHOT\");\r\n}\r\n\r\n\r\npunchAnimation() {\r\n    console.log(\"PUNCH\");\r\n}\r\n\r\n\r\nwalkAnimation() {\r\n    console.log(\"WALKING\");\r\n}\r\n\r\nrunAnimation() {\r\n    console.log(\"RUN\");\r\n}\r\n\r\nupdateEnemyAnimations() {\r\n    if (this.states.DESTROYED) return;\r\n\r\n    if (this.states.FOLLOWING || this.states.ATTACKING) {\r\n  \r\n        this.runAnimation();\r\n    } else {\r\n\r\n\r\n        if(!this.isSpellCasting) {\r\n        this.idleAnimation();\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\nmove(player: Player): void {\r\n    if(this.states.DESTROYED) return;\r\n    const distanceFromPlayer = player.position.subtract(this.rootMesh!.position).length();\r\n\r\n    if(distanceFromPlayer <= 2.5) \r\n    {\r\n        this.attackPlayer(player);\r\n\r\n    } \r\n    else if(distanceFromPlayer <= this.aggroRange) \r\n    {\r\n\r\n        if(!this.isAttacking && !this.isReacting) {\r\n            this.followPlayer(player);\r\n        }\r\n    } \r\n}\r\n\r\n\r\ngenerateRandomPosition() {\r\n    const randomPositionX = Math.floor((Math.random() * 100)) - (100 / 2);\r\n    const randomPositionZ = Math.floor((Math.random() * 100)) - (100 / 2);\r\n    \r\n\r\n    this.randPosition = new Vector3(randomPositionX, 0, randomPositionZ);\r\n}\r\n\r\nfollowPlayer(player: Player): void {\r\n    this.runAnimation();\r\n    this.states.ATTACKING = false;\r\n    this.states.FOLLOWING = true;\r\n\r\n       \r\n\r\n    const direction = player.position.subtract(this.rootMesh!.position).normalize();\r\n\r\n    \r\n    const alpha = Math.atan2(-direction.x, -direction.z);\r\n  \r\n\r\n    this.rootMesh!.rotation.y =  alpha;\r\n \r\n\r\n      \r\n       this.collider!.moveWithCollisions(direction.multiplyByFloats(this.runSpeed, 0, this.runSpeed));\r\n\r\n\r\n   \r\n}\r\n\r\nattackPlayer(player: Player): void {\r\n \r\n    \r\n\r\n    this.states.FOLLOWING = false;\r\n    this.states.ATTACKING = true;\r\n\r\n  \r\n\r\n    if (!this.attackTimer) {\r\n        const attackInterval = 1000 / this.attackSpeed; \r\n\r\n        const attackOnce = () => {\r\n            if (this.states.DESTROYED) {\r\n              \r\n                clearInterval(this.attackTimer);\r\n                this.attackTimer = null;\r\n                return;\r\n            }\r\n\r\n            if (this.isPlayerInRange(player)) {\r\n                if (player.health > 0) {\r\n                    player.health = Math.max(player.health-this.damage);\r\n\r\n                    if(this.appliesDot && !player.hasDot) {\r\n                        player.applyDot(2, 5000);\r\n                    }\r\n                   \r\n                    this.punchAnimation();\r\n                    this.attackSound.play();\r\n                   \r\n                } else {\r\n                    console.log(\"Player defeated!\");\r\n                }\r\n            }\r\n        };\r\n\r\n      \r\n        attackOnce();\r\n\r\n       \r\n        this.attackTimer = setInterval(attackOnce, attackInterval);\r\n    }\r\n}\r\n\r\n\r\nisPlayerInRange(player: Player): boolean {\r\n   \r\n    const distanceFromPlayer = player.position.subtract(this.rootMesh!.position).length();\r\n    return distanceFromPlayer <= 3.5; \r\n}\r\n\r\n\r\nremove() {\r\n    if (!this.mesh || !this.rootMesh) return;\r\n\r\n \r\n   \r\n    if (this.attackTimer) {\r\n        clearInterval(this.attackTimer);\r\n        this.attackTimer = null;\r\n    }\r\n\r\n   \r\n\r\n\r\n   \r\n    setTimeout(() => {\r\n        this.mesh!.dispose();\r\n        this.rootMesh!.dispose();\r\n       \r\n\r\n     \r\n        this.states.DESTROYED = true;\r\n\r\n       \r\n    }, 25000);\r\n}\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n","import { AnimationGroup, GizmoManager, PhysicsImpostor, Scene, SceneLoader, Sound, Tags, Vector3, TransformNode, MeshBuilder, StandardMaterial, Color3, AbstractMesh, Nullable, Animation, AssetContainer } from \"@babylonjs/core\";\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Level } from \"./Level\";\r\n\r\n\r\nexport class Mutant extends Enemy {\r\n    skeleton: any;\r\n    \r\n  \r\n    \r\n\r\n\r\n    constructor(scene: Scene, level: Level) {\r\n        super(scene, level);\r\n        this.name = \"Mutant\";\r\n        this.damage = 5;\r\n        this.scoreValue = 50;\r\n        this.attackSpeed = 0.4;\r\n        this.attackSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/attack/mutant.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                //spatialSound: true,\r\n                volume: 0.6,\r\n                autoplay: false\r\n            }\r\n        );\r\n\r\n        //this.attackSound.attachToMesh(this.rootMesh);\r\n\r\n        this.aggroRange = 200;\r\n\r\n        this.health = 150;\r\n\r\n    //this.transformNode = new TransformNode(\"RotationNode\", this.scene);\r\n    \r\n    }\r\n\r\n    async CreateMonster(position: Vector3): Promise<void> {\r\n\r\n\r\n        this.createBoxCollider();\r\n    \r\n       const clones = this.duplicate(this.level.instances.mutantAssetContainer, position);\r\n      \r\n   \r\n    \r\n        this.rootMesh!.position = position;\r\n        /* this.mesh!.position = this.rootMesh!.position.clone();\r\n        this.mesh.parent = this.rootMesh; */\r\n       /*  this.mesh.position = position; */\r\n        this.rootMesh!.checkCollisions = true;\r\n        //this.rootMesh.physicsImpostor = new PhysicsImpostor(this.rootMesh, PhysicsImpostor.MeshImpostor, { mass: 100, restitution: 0.1 }, this.scene);\r\n        this.rootMesh!.rotationQuaternion = null;\r\n      \r\n        \r\n        this.rootMesh!.position = position;\r\n        //this.mesh!.position = this.rootMesh!.position.clone(); \r\n       \r\n        this.collider.position = this.rootMesh!.position.clone();\r\n        \r\n        this.collider.position.y += 1;\r\n        //this.mesh.showBoundingBox = true;\r\n\r\n        //this.rootMesh.scaling = new Vector3(1.5,1.5,1.5);\r\n   \r\n             console.log(\"MUTANT CLONE ROOT:\", this.rootMesh, this.rootMesh!.isVisible);\r\n        console.log(\"Mutant root position:\", this.rootMesh?.position.x, this.rootMesh?.position.y, this.rootMesh?.position.z);\r\n   console.log(\"MUTANT CLONE MESH\", this.mesh, this.mesh!.isVisible);\r\n        console.log(\"Mutant mesh position:\", this.mesh!.position.x, this.mesh!.position.y, this.mesh!.position.z); \r\n        //this.rootMesh.physicsImpostor.setScalingUpdated();\r\n        //this.mesh.checkCollisions = true;\r\n\r\n      \r\n\r\n        //this.rootMesh!.parent = this.collider;\r\n        //this.rootMesh!.setParent(this.collider);\r\n\r\n        // Set animation groups\r\n       // Clone and set animation groups\r\n   /*  this.animationGroups = this.level.instances.mutantAnim.map((animGroup: AnimationGroup, index: number) => {\r\n        return animGroup.clone(`mutantAnim_${index}`, oldTarget => {\r\n            if (oldTarget === this.level.instances.mutantSkeleton[0]) {\r\n                return this.mesh!.skeleton;\r\n            }\r\n            return oldTarget;\r\n        }, true);\r\n    });\r\n       */\r\n\r\n        this.animationGroups = clones.animationGroups;\r\n        this.death =  this.animationGroups[1];\r\n        this.idle =  this.animationGroups[2];\r\n        this.punch =  this.animationGroups[3];\r\n        this.run =  this.animationGroups[4];\r\n        this.shot =  this.animationGroups[5];\r\n        this.uppercut =  this.animationGroups[6];\r\n        this.walk =  this.animationGroups[7];\r\n    \r\n     \r\n    \r\n        // Add tags\r\n        Tags.AddTagsTo(this.mesh, \"enemy\");\r\n    \r\n        // Start animations\r\n        this.animationGroups[0].stop();\r\n        this.animationGroups[4].play(true);\r\n    \r\n        // Set movement speeds\r\n        this.runSpeed = 0.3;\r\n        this.walkSpeed = 0.07;\r\n    \r\n\r\n     \r\n\r\n\r\n\r\n       \r\n     \r\n\r\n     \r\n\r\n            this.scene.registerBeforeRender(() => {\r\n               \r\n                this.rootMesh!.position.x = this.collider.position.x;\r\n                this.rootMesh!.position.z = this.collider.position.z;\r\n            });\r\n      \r\n    }\r\n    \r\n    createBoxCollider() {\r\n      \r\n        this.collider = MeshBuilder.CreateBox(\"collider\", { height: 1.5, width: 1, depth: 1 }, this.scene);\r\n       // this.collider.scaling = new Vector3(1.5, 3, 1.5); \r\n\r\n   \r\n\r\n       //this.collider.scaling.y = 0.5;\r\n    \r\n \r\n      \r\n        this.collider.visibility = 0.3;\r\n        this.collider.isVisible = false;\r\n    \r\n        this.collider.checkCollisions = true;\r\n        this.collider.isPickable = false;\r\n    \r\n       \r\n    }\r\n\r\ndeathAnimation() {\r\n    \r\n\r\n       this.isDead = true;\r\n\r\n\r\n       this.animationGroups[2].stop();\r\n       this.animationGroups[3].stop();\r\n       this.animationGroups[4].stop();\r\n       this.animationGroups[5].stop();\r\n\r\n\r\n        this.death.start(false);\r\n\r\n           \r\n    this.collider.dispose();\r\n    this.remove();\r\n \r\n    //console.log(\" DEAD\");\r\n    \r\n}\r\n\r\nidleAnimation() {\r\n\r\n    this.idle.start(false);\r\n    //console.log(\"IDLE\");\r\n}\r\n\r\nshotAnimation() {\r\n    this.isReacting = true;\r\n    \r\n    if(!this.shot.isPlaying) {\r\n        this.shot.play(false);\r\n        }\r\n     \r\n\r\n    this.shot.onAnimationEndObservable.addOnce(() => {\r\n        this.isReacting = false;\r\n    });\r\n    //console.log(\" SHOT\");\r\n}\r\n\r\n\r\npunchAnimation() {\r\n\r\n    this.animationGroups.forEach(animationGroup => {\r\n        animationGroup.stop();\r\n    });\r\n\r\n   this.isAttacking = true;\r\n   this.punch.start(false);\r\n\r\n   this.punch.onAnimationEndObservable.addOnce(() => {\r\n        this.isAttacking = false;\r\n    \r\n});\r\n\r\n   \r\n   //return this.animationGroups[1];\r\n    //console.log(\"PUNCH\");\r\n}\r\n\r\n\r\nwalkAnimation() {\r\n\r\n    this.walk.start(false);\r\n    //console.log(\"WALKING\");\r\n}\r\n\r\nrunAnimation() {\r\n    // Check if any other animation group is currently playing\r\n\r\n    this.idle.stop();\r\n    this.walk.stop();\r\n\r\n    const isAnyAnimationPlaying = this.animationGroups.some(animationGroup => animationGroup.isPlaying);\r\n\r\n    // Start the \"run\" animation group only if no other animation is currently playing\r\n    if (!isAnyAnimationPlaying) {\r\n        this.run.start(true);\r\n        //console.log(\"RUN\");\r\n    }\r\n}\r\n\r\ncloneAnimationGroups(sourceAnimationGroups: AnimationGroup[], targetMesh: AbstractMesh): AnimationGroup[] {\r\n    return sourceAnimationGroups.map(sourceGroup => {\r\n        const newGroup = new AnimationGroup(sourceGroup.name);\r\n        \r\n        sourceGroup.targetedAnimations.forEach(targetedAnim => {\r\n            const newAnim = targetedAnim.animation.clone();\r\n            newGroup.addTargetedAnimation(newAnim, targetMesh);\r\n        });\r\n        \r\n        return newGroup;\r\n    });\r\n\r\n\r\n}\r\n\r\n\r\nduplicate(container: AssetContainer, position: Vector3) {\r\n   \r\n\r\n    \r\n   const entries = container.instantiateModelsToScene(undefined, false, { doNotInstantiate: true });\r\n   console.log(entries);\r\n   this.rootMesh = entries.rootNodes[0] as AbstractMesh;\r\n   this.mesh = entries.rootNodes[0].getChildMeshes()[0]; \r\n   this.level.shadowGen.addShadowCaster(this.mesh);\r\n   this.rootMesh.setEnabled(true);\r\n   this.mesh.setEnabled(true);\r\n   for (const node of entries.rootNodes) {\r\n    if(node instanceof TransformNode) {\r\n        node.position = position;\r\n    }\r\n    \r\n}\r\n\r\nreturn entries;\r\n}\r\n\r\n}","import { AbstractMesh, Animation, Vector3, Scene, SceneLoader, FreeCamera, Sound, MeshBuilder, StandardMaterial, Texture, SpriteManager, Sprite, GlowLayer, Color3, Color4, Mesh, EasingFunction } from \"@babylonjs/core\";\r\n\r\nexport class WeaponPickups {\r\n\r\n    mesh: AbstractMesh | null;\r\n    scene!: Scene;\r\n    camera!: FreeCamera; \r\n    pickupSound: Sound;\r\n    spriteManager: any;\r\n    glowLayer: GlowLayer;\r\n\r\n    constructor() {\r\n        this.mesh = null;\r\n       this.pickupSound = new Sound(\r\n        \"weaponPickup\",\r\n        \"./audio/pickups/ammobox.mp3\",\r\n        this.scene,\r\n        null,\r\n        {\r\n            //spatialSound: true,\r\n            volume: 1,\r\n            autoplay: false\r\n        });\r\n\r\n\r\n        //this.spriteManager = new SpriteManager(\"spriteManager\", \"textures/arrow.png\", 1, 256, this.scene);\r\n\r\n\r\n        this.glowLayer = new GlowLayer(\"glow\", this.scene);\r\n        this.glowLayer.intensity = 1; \r\n\r\n    }\r\n\r\n\r\n\r\n    async CreateMinigunPickup(position: Vector3) {\r\n\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/pickups/', 'minigun.glb');\r\n        this.mesh = meshes[0]; \r\n        this.mesh.scaling = new Vector3(0.01, 0.01, 0.01);\r\n        this.mesh.position = position;\r\n        this.mesh.position.y += 0.1; \r\n      \r\n        meshes[1].checkCollisions = true;\r\n        meshes[1].id = \"minigunPickup\";\r\n\r\n     /*    const arrow = this.createGlowingArrow(meshes[1]);\r\n       \r\n        this.CreateAnimations(arrow); */\r\n       \r\n        \r\n    }\r\n\r\n\r\n    async CreatePistolPickup(position: Vector3) {\r\n\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/pickups/', 'pistol2.glb');\r\n        this.mesh = meshes[0]; \r\n       this.mesh.scaling = new Vector3(0.02, 0.02, 0.02);\r\n        this.mesh.position = position;\r\n        this.mesh.position.y += 0.1; \r\n      \r\n        meshes[1].checkCollisions = true;\r\n        meshes[1].id = \"pistolPickup\";\r\n\r\n   /*      const arrow = this.createGlowingArrow(meshes[1]);\r\n       \r\n        this.CreateAnimations(arrow); */\r\n       \r\n        \r\n    }\r\n\r\n    async CreateRiflePickup(position: Vector3) {\r\n\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/pickups/', 'rifle2.glb');\r\n        this.mesh = meshes[0]; \r\n        this.mesh.scaling = new Vector3(0.02, 0.02, 0.02);\r\n        this.mesh.position = position;\r\n        this.mesh.position.y += 0.1; \r\n      \r\n        meshes[1].checkCollisions = true;\r\n        meshes[1].id = \"riflePickup\";\r\n\r\n        /* const arrow = this.createGlowingArrow(meshes[1]);\r\n       \r\n        this.CreateAnimations(arrow);\r\n        */\r\n        \r\n    }\r\n\r\n    async CreateLMGPickup(position: Vector3) {\r\n\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/pickups/', 'lmg2.glb');\r\n        this.mesh = meshes[0]; \r\n        this.mesh.scaling = new Vector3(2, 2, 2);\r\n        this.mesh.position = position;\r\n        this.mesh.position.y += 0.1; \r\n      \r\n        meshes[1].checkCollisions = true;\r\n        meshes[1].id = \"lmgPickup\";\r\n\r\n        /* const arrow = this.createGlowingArrow(meshes[1]);\r\n       \r\n        this.CreateAnimations(arrow); */\r\n    }\r\n\r\n\r\n\r\n\r\n    /* async createGlowingArrow(parent: any) {\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/', 'arrow.glb');\r\n        const arrowMesh = meshes[0] as Mesh;\r\n        arrowMesh.scaling = new Vector3(0.5,0.5,0.5);\r\n     \r\n    \r\n        const arrowMaterial = new StandardMaterial('arrowMaterial', this.scene);\r\n        arrowMaterial.emissiveColor = Color3.FromHexString('#00FF00'); \r\n\r\n        arrowMesh.material = arrowMaterial;\r\n   \r\n         \r\n        // Parent arrow to the  mesh\r\n        arrowMesh.setParent(parent);\r\n\r\n        arrowMesh.position = parent.position.clone();\r\n        \r\n        \r\n       return arrowMesh;\r\n\r\n\r\n\r\n        \r\n\r\n        \r\n    }\r\n */\r\n\r\n  /*   CreateAnimations(mesh: any) {\r\n        const rotateFrames = [];\r\n        const fps = 60;\r\n\r\n        const rotateAnim = new Animation(\"rotateAnim\", \"rotation.y\", fps, Animation.ANIMATIONTYPE_FLOAT, Animation.ANIMATIONLOOPMODE_CONSTANT);\r\n\r\n\r\n        rotateFrames.push({frame: 0, value:0});\r\n        rotateFrames.push({frame: 180, value:Math.PI/2});\r\n\r\n\r\n        rotateAnim.setKeys(rotateFrames);\r\n\r\n\r\n        mesh.animations.push(rotateAnim);\r\n\r\n\r\n        this.scene.beginAnimation(mesh, 0, 180 )\r\n    }\r\n     */\r\n  \r\n}","import { AbstractMesh, Vector3, Scene, SceneLoader, FreeCamera, Sound, Mesh } from \"@babylonjs/core\";\r\n\r\nexport class AmmoPickup {\r\n\r\n    mesh: AbstractMesh | null;\r\n    scene!: Scene;\r\n    camera!: FreeCamera; \r\n    pickupSound: Sound;\r\n    meshes: any;\r\n\r\n    constructor(scene: Scene, camera: FreeCamera) {\r\n        this.mesh = null;\r\n        this.scene = scene;\r\n       this.pickupSound = new Sound(\r\n        \"ammoBoxPickup\",\r\n        \"./audio/pickups/ammobox.mp3\", \r\n        this.scene,\r\n        null,\r\n        {\r\n            //spatialSound: true,\r\n            volume: 1,\r\n            autoplay: false\r\n        });\r\n\r\n\r\n        this.camera = camera;\r\n        \r\n    }\r\n\r\n    async CreateAmmoPickup(position: Vector3) {\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/', 'ammocrate.glb');\r\n        this.mesh = meshes[0]; \r\n        this.mesh.scaling = new Vector3(-2.5, 2.5, 2.5);\r\n        this.mesh.position = position; \r\n      \r\n        meshes[1].checkCollisions = true;\r\n        meshes[1].id = \"ammoBox\";\r\n       \r\n        \r\n    }\r\n\r\n    collectAmmo() {\r\n\r\n        if (this.mesh) {\r\n            this.mesh.dispose();\r\n            this.mesh = null;\r\n        }\r\n    }\r\n\r\n    checkFrustumVisibility(): void {\r\n        if(this.meshes) {\r\n       \r\n        this.meshes.forEach((mesh: Mesh) => {\r\n            if (!this.camera.isInFrustum(mesh)) {\r\n                mesh.isVisible = false;\r\n            } else {\r\n                mesh.isVisible = true;\r\n            }\r\n        });\r\n    }\r\n}\r\n}\r\n","import { AbstractMesh, Tags, Animation, AnimationGroup, Color3, FreeCamera, Material, Mesh, MeshBuilder, PBRMaterial, Ray, Scene, SceneLoader, Sound, StandardMaterial, Texture, TransformNode, Vector3, Axis, RichTypeString } from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\n\r\n\r\nexport class FirstAidPickup {\r\n\r\n    mesh: AbstractMesh | null;\r\n    pickupSound: Sound;\r\n    scene!: Scene;\r\n    meshes: any;\r\n    camera!: FreeCamera;\r\n\r\n\r\n    constructor(scene: Scene, camera: FreeCamera) {\r\n        this.mesh = null;\r\n        this.scene = scene;\r\n        this.pickupSound = new Sound(\r\n            \"firstAidPickup\",\r\n            \"./audio/pickups/firstaid.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                //spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            });\r\n          this.camera = camera;\r\n    }\r\n\r\n    async CreateFirstAidPickup(position: Vector3) {\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/', 'firstaid.glb');\r\n        meshes[1].checkCollisions = true;\r\n        this.mesh = meshes[0];\r\n        meshes[0].scaling = new Vector3(-2.5,2.5,2.5);\r\n        this.mesh.position = position; \r\n        //this.mesh.checkCollisions = true;\r\n        meshes[1].id = \"firstAid\";\r\n    }\r\n\r\n\r\n    checkFrustumVisibility(): void {\r\n        if(this.meshes) {\r\n       \r\n        this.meshes.forEach((mesh: Mesh) => {\r\n            if (!this.camera.isInFrustum(mesh)) {\r\n                mesh.isVisible = false;\r\n            } else {\r\n                mesh.isVisible = true;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n}","import { AnimationGroup, GizmoManager, PhysicsImpostor, Scene, SceneLoader, Sound, Tags, Vector3, TransformNode, MeshBuilder, StandardMaterial, Color3, AssetContainer, AbstractMesh } from \"@babylonjs/core\";\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Level } from \"./Level\";\r\n\r\n\r\nexport class Warrok extends Enemy {\r\n    \r\n  \r\n    \r\n\r\n\r\n    constructor(scene: Scene, level: Level) {\r\n        super(scene, level);\r\n        this.name = \"Warrok\";\r\n        this.damage = 12;\r\n        this.scoreValue = 100;\r\n        this.attackSpeed = 0.4;\r\n        this.attackSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/attack/mutant.mp3\",\r\n            this.scene,\r\n            null,\r\n            {\r\n                //spatialSound: true,\r\n                volume: 0.6,\r\n                autoplay: false\r\n            }\r\n        );\r\n\r\n        //this.attackSound.attachToMesh(this.rootMesh);\r\n\r\n        this.aggroRange = 200;\r\n        \r\n\r\n\r\n        \r\n    //this.transformNode = new TransformNode(\"RotationNode\", this.scene);\r\n    this.health = 120;\r\n    }\r\n\r\n    async CreateMonster(position: Vector3): Promise<void> {\r\n\r\n\r\n        this.createBoxCollider();\r\n    \r\n\r\n        const clones = this.duplicate(this.level.instances.warrokAssetContainer, position);\r\n\r\n       \r\n\r\n        this.rootMesh!.checkCollisions = true;\r\n        //this.rootMesh.physicsImpostor = new PhysicsImpostor(this.rootMesh, PhysicsImpostor.MeshImpostor, { mass: 100, restitution: 0.1 }, this.scene);\r\n        this.rootMesh!.rotationQuaternion = null;\r\n        \r\n        this.rootMesh!.position = position;\r\n        this.collider.position = this.rootMesh!.position.clone();\r\n        this.collider.position.y += 1;\r\n        //this.mesh.showBoundingBox = true;\r\n\r\n        //this.rootMesh.scaling = new Vector3(1.5,1.5,1.5);\r\n   \r\n            \r\n        //this.rootMesh.physicsImpostor.setScalingUpdated();\r\n        //this.mesh.checkCollisions = true;\r\n     \r\n      \r\n\r\n        //this.rootMesh!.parent = this.collider;\r\n        //this.rootMesh!.setParent(this.collider);\r\n\r\n        // Set animation groups\r\n        this.animationGroups = clones.animationGroups;\r\n        this.death = this.animationGroups[1];\r\n        this.idle = this.animationGroups[2];\r\n        this.punch = this.animationGroups[3];\r\n        this.run = this.animationGroups[4];\r\n        this.shot = this.animationGroups[5];\r\n        this.walk = this.animationGroups[2];\r\n    \r\n     \r\n    \r\n        // Add tags\r\n        Tags.AddTagsTo(this.mesh, \"enemy\");\r\n    \r\n        // Start animations\r\n        this.animationGroups[0].stop();\r\n        this.animationGroups[4].play(true);\r\n    \r\n        // Set movement speeds\r\n        this.runSpeed = 0.2;\r\n        this.walkSpeed = 0.07;\r\n    \r\n        //console.log(animationGroups);\r\n\r\n\r\n     \r\n\r\n\r\n\r\n       \r\n\r\n            this.scene.registerBeforeRender(() => {\r\n                \r\n                this.rootMesh!.position.x = this.collider.position.x;\r\n                this.rootMesh!.position.z = this.collider.position.z;\r\n            });\r\n      \r\n    }\r\n    \r\n    createBoxCollider() {\r\n    \r\n        this.collider = MeshBuilder.CreateBox(\"collider\", { height: 1.5, width: 1, depth: 1 }, this.scene);\r\n       // this.collider.scaling = new Vector3(1.5, 3, 1.5); \r\n\r\n   \r\n\r\n       //this.collider.scaling.y = 0.5;\r\n    \r\n \r\n      \r\n        this.collider.visibility = 0.3;\r\n    \r\n        this.collider.checkCollisions = true;\r\n        this.collider.isPickable = false;\r\n        this.collider.isVisible = false;\r\n       \r\n    }\r\n\r\ndeathAnimation() {\r\n    \r\n\r\n       this.isDead = true;\r\n\r\n\r\n       this.animationGroups[2].stop();\r\n       this.animationGroups[3].stop();\r\n       this.animationGroups[4].stop();\r\n       this.animationGroups[5].stop();\r\n\r\n\r\n        this.death.start(false);\r\n\r\n           \r\n    this.collider.dispose();\r\n\r\n    this.remove();\r\n \r\n   // console.log(\" DEAD\");\r\n    \r\n}\r\n\r\nidleAnimation() {\r\n\r\n    this.idle.start(false);\r\n    //console.log(\"IDLE\");\r\n}\r\n\r\nshotAnimation() {\r\n    this.isReacting = true;\r\n    if(!this.shot.isPlaying) {\r\n        this.shot.play(false);\r\n        }\r\n     \r\n    this.shot.onAnimationEndObservable.addOnce(() => {\r\n        this.isReacting = false;\r\n    });\r\n    //console.log(\" SHOT\");\r\n}\r\n\r\n\r\npunchAnimation() {\r\n\r\n    this.animationGroups.forEach(animationGroup => {\r\n        animationGroup.stop();\r\n    });\r\n\r\n   this.isAttacking = true;\r\n   this.punch.start(false);\r\n\r\n   this.punch.onAnimationEndObservable.addOnce(() => {\r\n        this.isAttacking = false;\r\n    \r\n});\r\n   \r\n   //return this.animationGroups[1];\r\n    //console.log(\"PUNCH\");\r\n}\r\n\r\n\r\nwalkAnimation() {\r\n\r\n    this.walk.start(false);\r\n    //console.log(\"WALKING\");\r\n}\r\n\r\nrunAnimation() {\r\n   \r\n\r\n    this.idle.stop();\r\n    this.walk.stop();\r\n\r\n    const isAnyAnimationPlaying = this.animationGroups.some(animationGroup => animationGroup.isPlaying);\r\n\r\n   \r\n    if (!isAnyAnimationPlaying) {\r\n        this.run.start(true);\r\n        \r\n    }\r\n}\r\n\r\n\r\nduplicate(container: AssetContainer, position: Vector3) {\r\n   \r\n\r\n    \r\n    const entries = container.instantiateModelsToScene(undefined, false, { doNotInstantiate: true });\r\n    console.log(entries);\r\n    this.rootMesh = entries.rootNodes[0] as AbstractMesh;\r\n    this.mesh = entries.rootNodes[0].getChildMeshes()[0]; \r\n    this.rootMesh.setEnabled(true);\r\n    this.mesh.setEnabled(true);\r\n    for (const node of entries.rootNodes) {\r\n     if(node instanceof TransformNode) {\r\n         node.position = position;\r\n     }\r\n     \r\n }\r\n \r\n return entries;\r\n }\r\n \r\n\r\n\r\n\r\n}","import { AnimationGroup, GizmoManager, PhysicsImpostor, Scene, SceneLoader, Sound, Tags, Vector3, TransformNode, MeshBuilder, StandardMaterial, Color3, AssetContainer, AbstractMesh } from \"@babylonjs/core\";\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Level } from \"./Level\";\r\n\r\nexport class SkeletonZombie extends Enemy {\r\n    \r\n  \r\n    \r\n\r\n\r\n    constructor(scene: Scene, level: Level) {\r\n        super(scene, level);\r\n        this.name = \"SkeletonZombie\";\r\n        this.damage = 10;\r\n        this.scoreValue = 200;\r\n        this.attackSpeed = 0.4;\r\n        this.attackSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/attack/mutant.mp3\",\r\n            this.scene,\r\n            null,\r\n            {\r\n                //spatialSound: true,\r\n                volume: 0.6,\r\n                autoplay: false\r\n            }\r\n        );\r\n\r\n        //this.attackSound.attachToMesh(this.rootMesh);\r\n\r\n        this.aggroRange = 200;\r\n\r\n        this.health = 200;\r\n        \r\n    this.transformNode = new TransformNode(\"RotationNode\", this.scene);\r\n    \r\n    this.appliesDot = true;\r\n    }\r\n\r\n    async CreateMonster(position: Vector3): Promise<void> {\r\n\r\n\r\n        this.createBoxCollider();\r\n    \r\n\r\n        \r\n        const clones = this.duplicate(this.level.instances.skeletonZombieAssetContainer, position);\r\n\r\n       \r\n/*     \r\n    // Set monster properties\r\n        this.mesh = meshes[1];\r\n        this.rootMesh = meshes[0]; */\r\n\r\n        /* this.rootMesh.physicsImpostor = new PhysicsImpostor(\r\n            this.rootMesh,\r\n            PhysicsImpostor.BoxImpostor,\r\n            { mass: 1, restitution: 0.1, friction: 0 },\r\n            this.scene\r\n        );\r\n */\r\n\r\n        this.rootMesh!.checkCollisions = true;\r\n        //this.rootMesh.physicsImpostor = new PhysicsImpostor(this.rootMesh, PhysicsImpostor.MeshImpostor, { mass: 100, restitution: 0.1 }, this.scene);\r\n        this.rootMesh!.rotationQuaternion = null;\r\n        \r\n        this.rootMesh!.position = position;\r\n        this.collider.position = this.rootMesh!.position.clone();\r\n        this.collider.position.y += 1;\r\n        //this.mesh.showBoundingBox = true;\r\n\r\n        //this.rootMesh.scaling = new Vector3(1.5,1.5,1.5);\r\n   \r\n            \r\n        //this.rootMesh.physicsImpostor.setScalingUpdated();\r\n        //this.mesh.checkCollisions = true;\r\n      // Create a box collider\r\n      \r\n\r\n        //this.rootMesh!.parent = this.collider;\r\n        //this.rootMesh!.setParent(this.collider);\r\n\r\n        // Set animation groups\r\n        this.animationGroups = clones.animationGroups;\r\n        this.death = this.animationGroups[1];\r\n        this.idle = this.animationGroups[2];\r\n        this.punch = this.animationGroups[3];\r\n        this.run = this.animationGroups[4];\r\n        this.shot = this.animationGroups[5];\r\n        this.uppercut = this.animationGroups[3];\r\n        this.walk = this.animationGroups[6];\r\n    \r\n     \r\n    \r\n        // Add tags\r\n        Tags.AddTagsTo(this.mesh, \"enemy\");\r\n    \r\n        // Start animations\r\n        this.animationGroups[0].stop();\r\n        this.animationGroups[4].play(true);\r\n    \r\n        // Set movement speeds\r\n        this.runSpeed = 0.6;\r\n        this.walkSpeed = 0.07;\r\n    \r\n  // Add physics impostor\r\n     \r\n\r\n\r\n\r\n       \r\n     \r\n\r\n\r\n            this.scene.registerBeforeRender(() => {\r\n               \r\n                this.rootMesh!.position.x = this.collider.position.x;\r\n                this.rootMesh!.position.z = this.collider.position.z;\r\n            });\r\n      \r\n    }\r\n    \r\n    createBoxCollider() {\r\n      \r\n        this.collider = MeshBuilder.CreateBox(\"collider\", { height: 1.5, width: 1, depth: 1 }, this.scene);\r\n       // this.collider.scaling = new Vector3(1.5, 3, 1.5);\r\n\r\n   \r\n\r\n       //this.collider.scaling.y = 0.5;\r\n    \r\n \r\n      \r\n        this.collider.visibility = 0.3;\r\n        this.collider.isVisible = false;\r\n        this.collider.checkCollisions = true;\r\n        this.collider.isPickable = false;\r\n    \r\n       \r\n    }\r\n\r\ndeathAnimation() {\r\n    \r\n\r\n       this.isDead = true;\r\n\r\n\r\n       this.animationGroups[2].stop();\r\n       this.animationGroups[3].stop();\r\n       this.animationGroups[4].stop();\r\n       this.animationGroups[5].stop();\r\n\r\n\r\n        this.death.start(false);\r\n\r\n           \r\n    this.collider.dispose();\r\n    this.remove();\r\n \r\n    //console.log(\" DEAD\");\r\n    \r\n}\r\n\r\nidleAnimation() {\r\n\r\n    this.idle.start(false);\r\n    //console.log(\"IDLE\");\r\n}\r\n\r\nshotAnimation() {\r\n    this.isReacting = true;\r\n    if(!this.shot.isPlaying) {\r\n        this.shot.play(false);\r\n        }\r\n\r\n\r\n    this.shot.onAnimationEndObservable.addOnce(() => {\r\n        this.isReacting = false;\r\n    });\r\n    //console.log(\" SHOT\");\r\n}\r\n\r\n\r\npunchAnimation() {\r\n\r\n    this.animationGroups.forEach(animationGroup => {\r\n        animationGroup.stop();\r\n    });\r\n\r\n\r\n\r\n   this.isAttacking = true;\r\n   this.punch.start(false);\r\n\r\n   this.punch.onAnimationEndObservable.addOnce(() => {\r\n        this.isAttacking = false;\r\n    \r\n});\r\n   \r\n   //return this.animationGroups[1];\r\n    //console.log(\"PUNCH\");\r\n}\r\n\r\n\r\nwalkAnimation() {\r\n\r\n    this.walk.start(false);\r\n    //console.log(\"WALKING\");\r\n}\r\n\r\nrunAnimation() {\r\n    // Check if any other animation group is currently playing\r\n\r\n    this.idle.stop();\r\n    this.walk.stop();\r\n\r\n    const isAnyAnimationPlaying = this.animationGroups.some(animationGroup => animationGroup.isPlaying);\r\n\r\n    // Start the \"run\" animation group only if no other animation is currently playing\r\n    if (!isAnyAnimationPlaying) {\r\n        this.run.start(true);\r\n       // console.log(\"RUN\");\r\n    }\r\n}\r\n\r\nduplicate(container: AssetContainer, position: Vector3) {\r\n   \r\n\r\n    \r\n    const entries = container.instantiateModelsToScene(undefined, false, { doNotInstantiate: true });\r\n    console.log(entries);\r\n    this.rootMesh = entries.rootNodes[0] as AbstractMesh;\r\n    this.mesh = entries.rootNodes[0].getChildMeshes()[0]; \r\n    this.rootMesh.setEnabled(true);\r\n    this.mesh.setEnabled(true);\r\n    for (const node of entries.rootNodes) {\r\n     if(node instanceof TransformNode) {\r\n         node.position = position;\r\n     }\r\n     \r\n }\r\n \r\n return entries;\r\n }\r\n \r\n}","import { AnimationGroup, GizmoManager, PhysicsImpostor, Scene, SceneLoader, Sound, Tags, Vector3, TransformNode, MeshBuilder, StandardMaterial, Color3, ParticleSystem, Texture, Color4, GlowLayer, AssetContainer, AbstractMesh } from \"@babylonjs/core\";\r\nimport { Enemy } from \"./Enemy\";\r\n\r\nimport { Player } from \"./Player\";\r\nimport { Level } from \"./Level\";\r\nimport { Mutant } from \"./Mutant\";\r\nimport { SkeletonZombie } from \"./SkeletonZombie\";\r\nimport { Warrok } from \"./Warrok\";\r\n\r\n\r\nexport class Boss extends Enemy {\r\n    \r\n  \r\n    spellcast!: AnimationGroup;\r\n\r\n    spellParticles!: ParticleSystem;\r\n    isSpellCasting: boolean;\r\n    spellInterval!: number;\r\n\r\n    isVulnerable!: boolean;\r\n\r\n\r\n    player: Player;\r\n    glowInterval!: number;\r\n    glowLayer: any;\r\n    shockWaveSound: Sound;\r\n    shockWaveCastSound: Sound;\r\n    level: Level;\r\n    generateAddsInterval!: number;\r\n\r\n    constructor(scene: Scene, player: Player, level: Level) {\r\n        super(scene, level);\r\n        this.name = \"Boss\";\r\n        this.level = level;\r\n        this.player = player;\r\n        this.scoreValue = 2000;\r\n        this.attackSpeed = 0.4;\r\n    \r\n        this.attackSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/attack/mutant.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                //spatialSound: true,\r\n                volume: 0.6,\r\n                autoplay: false\r\n            }\r\n        );\r\n\r\n\r\n        this.shockWaveSound = new Sound(\r\n            \"shockWaveSound\",\r\n            \"./audio/attack/shockwave.mp3\",\r\n            this.scene,\r\n            null,\r\n            {\r\n                volume: 3,\r\n                autoplay: false\r\n            }\r\n        );\r\n        \r\n        this.shockWaveCastSound = new Sound(\r\n            \"shockWaveSound\",\r\n            \"./audio/attack/shockwaveCast.mp3\",\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 3,\r\n                autoplay: false\r\n            }\r\n        );\r\n\r\n        \r\n\r\n        //this.attackSound.attachToMesh(this.rootMesh);\r\n\r\n        this.aggroRange = 200;\r\n\r\n        this.health = 35000;\r\n\r\n        this.damage = 30;\r\n        this.isSpellCasting = false;\r\n\r\n\r\n        this.isVulnerable = true; // Initially, the boss is vulnerable\r\n        //this.startVulnerabilityTimer();\r\n\r\n        \r\n    //this.transformNode = new TransformNode(\"RotationNode\", this.scene);\r\n    \r\n    }\r\n\r\n    async CreateMonster(position: Vector3): Promise<void> {\r\n\r\n\r\n        this.createBoxCollider();\r\n    \r\n\r\n        this.collider.scaling = new Vector3(3,3,3);\r\n        this.collider.isVisible = false;\r\n        \r\n        const clones = this.duplicate(this.level.instances.bossAssetContainer, position);\r\n   \r\n        this.mesh!.scaling = new Vector3(3,3,3);\r\n\r\n        /* this.rootMesh.physicsImpostor = new PhysicsImpostor(\r\n            this.rootMesh,\r\n            PhysicsImpostor.BoxImpostor,\r\n            { mass: 1, restitution: 0.1, friction: 0 },\r\n            this.scene\r\n        );\r\n */\r\n\r\n        this.rootMesh!.checkCollisions = true;\r\n        //this.rootMesh.physicsImpostor = new PhysicsImpostor(this.rootMesh, PhysicsImpostor.MeshImpostor, { mass: 100, restitution: 0.1 }, this.scene);\r\n        this.rootMesh!.rotationQuaternion = null;\r\n        \r\n        this.rootMesh!.position = position;\r\n        this.collider.position = this.rootMesh!.position.clone();\r\n        this.collider.position.y += 1;\r\n        //this.mesh.showBoundingBox = true;\r\n\r\n        //this.rootMesh.scaling = new Vector3(1.5,1.5,1.5);\r\n   \r\n            \r\n        //this.rootMesh.physicsImpostor.setScalingUpdated();\r\n        //this.mesh.checkCollisions = true;\r\n      // Create a box collider\r\n      \r\n\r\n        //this.rootMesh!.parent = this.collider;\r\n        //this.rootMesh!.setParent(this.collider);\r\n\r\n        // Set animation groups\r\n        this.animationGroups = clones.animationGroups;\r\n        this.death = this.animationGroups[1];\r\n        this.idle = this.animationGroups[2];\r\n        this.punch = this.animationGroups[3];\r\n        this.run = this.animationGroups[4];\r\n        this.shot = this.animationGroups[5];\r\n        this.uppercut = this.animationGroups[6];\r\n        this.spellcast = this.animationGroups[6];\r\n        this.walk = this.animationGroups[7];\r\n        \r\n    \r\n     \r\n        this.run.speedRatio = 0.2;\r\n        // Add tags\r\n        Tags.AddTagsTo(this.mesh, \"enemy\");\r\n    \r\n        // Start animations\r\n        this.animationGroups[0].stop();\r\n        this.animationGroups[4].play(true);\r\n    \r\n        // Set movement speeds\r\n        this.runSpeed = 0.1;\r\n        this.walkSpeed = 0.07;\r\n    \r\n      \r\n     \r\n\r\n\r\n\r\n       \r\n     \r\n\r\n\r\n            this.scene.registerBeforeRender(() => {\r\n                \r\n                this.rootMesh!.position.x = this.collider.position.x;\r\n                this.rootMesh!.position.z = this.collider.position.z;\r\n            });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            this.loadParticleSystem();\r\n\r\n\r\n\r\n\r\n            this.startSpellcastingInterval();\r\n            this.startAddGeneration();\r\n\r\n\r\n \r\n            this.shockWaveCastSound.attachToMesh(this.mesh!);\r\n\r\n      \r\n    }\r\n    \r\n    createBoxCollider() {\r\n      \r\n        this.collider = MeshBuilder.CreateBox(\"collider\", { height: 1.5, width: 1, depth: 1 }, this.scene);\r\n       // this.collider.scaling = new Vector3(1.5, 3, 1.5); \r\n\r\n   \r\n\r\n       //this.collider.scaling.y = 0.5;\r\n    \r\n \r\n      \r\n        this.collider.visibility = 0.3;\r\n    \r\n        this.collider.checkCollisions = true;\r\n        this.collider.isPickable = false;\r\n    \r\n       \r\n    }\r\n\r\ndeathAnimation() {\r\n    \r\n\r\n       this.isDead = true;\r\n\r\n\r\n       this.animationGroups[2].stop();\r\n       this.animationGroups[3].stop();\r\n       this.animationGroups[4].stop();\r\n       this.animationGroups[5].stop();\r\n\r\n\r\n        this.death.start(false);\r\n\r\n           \r\n    this.collider.dispose();\r\n    this.remove();\r\n \r\n\r\n    this.level.stopWaveSystem();\r\n    clearInterval(this.generateAddsInterval);\r\n\r\n\r\n    this.death.onAnimationEndObservable.addOnce(()=> {\r\n        setTimeout(() => {\r\n        this.player.firstPersonController.ui.createWinScreen();\r\n        this.player.firstPersonController.camera.detachControl();\r\n    }, 5000);\r\n    });\r\n \r\n\r\n\r\n\r\n    \r\n}\r\n\r\nidleAnimation() {\r\n\r\n    if(!this.isSpellCasting) {\r\n        this.idle.start(true);\r\n    }\r\n\r\n}\r\n\r\nshotAnimation() {\r\n    if(!this.shot.isPlaying) {\r\n    this.shot.play(false);\r\n    }\r\n \r\n}\r\n\r\n\r\npunchAnimation() {\r\n\r\n    this.animationGroups.forEach(animationGroup => {\r\n        animationGroup.stop();\r\n    });\r\n\r\n    this.isAttacking = true;\r\n    this.punch.start(false);\r\n \r\n    this.punch.onAnimationEndObservable.addOnce(() => {\r\n         this.isAttacking = false;\r\n     \r\n });\r\n   \r\n\r\n}\r\n\r\n\r\nwalkAnimation() {\r\n\r\n    this.walk.start(false);\r\n\r\n}\r\n\r\nrunAnimation() {\r\n    // Check if any other animation group is currently playing\r\n\r\n    this.idle.stop();\r\n    this.walk.stop();\r\n\r\n    const isAnyAnimationPlaying = this.animationGroups.some(animationGroup => animationGroup.isPlaying);\r\n\r\n    // Start the \"run\" animation group only if no other animation is currently playing\r\n    if (!isAnyAnimationPlaying) {\r\n        this.run.speedRatio = 0.2; // Set the speed ratio to 0.5 to play at half speed\r\n\r\n        this.run.start(true);\r\n      \r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\nspellAnimation() {\r\n    this.animationGroups.forEach(animationGroup => {\r\n        animationGroup.stop();\r\n    });\r\n\r\n    this.isSpellCasting = true;\r\n    this.spellcast.start(false);\r\n    this.spellParticles.start();\r\n    this.shockWaveCastSound.play();\r\n\r\n    this.spellcast.onAnimationEndObservable.addOnce(() => {\r\n        this.isSpellCasting = false;\r\n        this.spellParticles.stop();\r\n        this.player.applyShockwave();\r\n\r\n        this.shockWaveCastSound.stop();\r\n        this.shockWaveSound.play();\r\n\r\n    });\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nloadParticleSystem() {\r\n    // Create and configure the particle system\r\nconst particleSystem = new ParticleSystem(\"particles\", 2000, this.scene);\r\n\r\n// Texture of each particle\r\nparticleSystem.particleTexture = new Texture(\"./textures/particles/spark_05.png\", this.scene);\r\n\r\n\r\nparticleSystem.emitter = this.rootMesh; \r\nparticleSystem.minEmitBox = new Vector3(1, 0, 1);\r\nparticleSystem.maxEmitBox = new Vector3(1, 0, 1);   \r\n\r\nparticleSystem.createSphereEmitter(9); \r\n\r\n// Colors of all particles\r\nparticleSystem.color1 = new Color4(0, 1, 1, 1.0);\r\nparticleSystem.color2 = new Color4(0, 1, 1, 1.0);\r\nparticleSystem.colorDead = new Color4(0, 1, 1, 0.0);\r\n\r\n\r\nparticleSystem.minSize = 2;\r\nparticleSystem.maxSize = 4;\r\n\r\n\r\nparticleSystem.minLifeTime = 0.2;\r\nparticleSystem.maxLifeTime = 0.2;\r\n\r\n\r\nparticleSystem.minInitialRotation = -Math.PI/3;\r\nparticleSystem.maxInitialRotation = Math.PI/3;\r\n\r\n// Emission rate\r\nparticleSystem.emitRate = 70;\r\n\r\n// Blend mode\r\nparticleSystem.blendMode = ParticleSystem.BLENDMODE_ONEONE;\r\n\r\n\r\n\r\n\r\n\r\n/* particleSystem.direction1 = new Vector3(15, 15, 0);\r\nparticleSystem.direction2 = new Vector3(0, 15, 15); */\r\n\r\n// Angular speed\r\n/* particleSystem.minAngularSpeed = 0;\r\nparticleSystem.maxAngularSpeed = Math.PI; */\r\n\r\n// Speed\r\n/* particleSystem.minEmitPower = 1;\r\nparticleSystem.maxEmitPower = 3;\r\nparticleSystem.updateSpeed = 0.007; */\r\n\r\n\r\nthis.spellParticles = particleSystem;\r\n//this.spellParticles.start();\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nmove(player: Player): void {\r\n    if(this.states.DESTROYED) return;\r\n    const distanceFromPlayer = player.position.subtract(this.rootMesh!.position).length();\r\n\r\n    if(distanceFromPlayer <= 5 && !this.isSpellCasting) \r\n    {\r\n        this.attackPlayer(player);\r\n\r\n    } \r\n    else if(distanceFromPlayer <= this.aggroRange && !this.isSpellCasting) \r\n    {\r\n\r\n        this.followPlayer(player);\r\n    } \r\n   \r\n}\r\n\r\n\r\n\r\nfollowPlayer(player: Player): void {\r\n    this.run.speedRatio = 0.2;\r\n    this.runAnimation();\r\n    this.states.ATTACKING = false;\r\n    this.states.FOLLOWING = true;\r\n\r\n       \r\n\r\n    const direction = player.position.subtract(this.rootMesh!.position).normalize();\r\n\r\n    \r\n    const alpha = Math.atan2(-direction.x, -direction.z);\r\n  \r\n\r\n    this.rootMesh!.rotation.y =  alpha;\r\n \r\n\r\n      \r\n       this.collider!.moveWithCollisions(direction.multiplyByFloats(this.runSpeed, 0, this.runSpeed));\r\n\r\n    \r\n   \r\n}\r\n\r\nattackPlayer(player: Player): void {\r\n \r\n\r\n    this.states.FOLLOWING = false;\r\n    this.states.ATTACKING = true;\r\n\r\n\r\n    if (!this.attackTimer) {\r\n        const attackInterval = 1000 / this.attackSpeed; // Interval between attacks in milliseconds\r\n\r\n        const attackOnce = () => {\r\n            if (this.states.DESTROYED) {\r\n                \r\n                clearInterval(this.attackTimer);\r\n                this.attackTimer = null;\r\n                return;\r\n            }\r\n\r\n            if (this.isPlayerInRange(player)) {\r\n                if (player.health > 0) {\r\n                    player.health = Math.max(player.health-this.damage);\r\n\r\n                    if(this.appliesDot && !player.hasDot) {\r\n                        player.applyDot(2, 5000);\r\n                    }\r\n                   \r\n                    this.punchAnimation();\r\n                    this.attackSound.play();\r\n                    //console.log(`Player attacked! Player's health: ${player.health}`);\r\n                } else {\r\n                   // console.log(\"Player defeated!\");\r\n                }\r\n            }\r\n        };\r\n\r\n     \r\n        attackOnce();\r\n\r\n        this.attackTimer = setInterval(attackOnce, attackInterval);\r\n    }\r\n}\r\n\r\n\r\nisPlayerInRange(player: Player): boolean {\r\n\r\n    const distanceFromPlayer = player.position.subtract(this.rootMesh!.position).length();\r\n    return distanceFromPlayer <= 5; \r\n}\r\n\r\n\r\nstartSpellcastingInterval() {\r\n    this.spellInterval = setInterval(() => {\r\n        if (!this.isSpellCasting && !this.isDead) {\r\n            this.spellAnimation();\r\n        }\r\n    }, 15000); // 15000 milliseconds = 15 seconds\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nstartVulnerabilityTimer() {\r\n    this.glowInterval = setInterval(() => {\r\n        this.isVulnerable = !this.isVulnerable; // Toggle vulnerability\r\n        if (!this.isVulnerable) {\r\n            // If boss is not vulnerable, add glow effect\r\n            this.addGlowEffect();\r\n        } else {\r\n            // If boss is vulnerable, remove glow effect\r\n            this.removeGlowEffect();\r\n        }\r\n    }, 10000); // 10000 milliseconds = 10 seconds\r\n}\r\n\r\naddGlowEffect() {\r\n    // Create a glow layer\r\n    this.glowLayer = new GlowLayer(\"glow\", this.scene);\r\n    this.glowLayer.addIncludedOnlyMesh(this.rootMesh);\r\n\r\n    // Set glow properties\r\n    this.glowLayer.intensity = 3; \r\n    this.glowLayer.glowColor = new Color3(0, 1, 1);\r\n}\r\n\r\nremoveGlowEffect() {\r\n    // Dispose the glow layer\r\n    if (this.glowLayer) {\r\n        this.glowLayer.dispose();\r\n        this.glowLayer = null;\r\n    }\r\n}\r\n\r\n\r\n\r\nasync generateAdds(number: number) {\r\n    \r\n    const minX = -82; // Minimum X coordinate of the walls\r\n    const maxX = 12; // Maximum X coordinate of the walls\r\n    const minZ = -8; // Minimum Z coordinate of the walls\r\n    const maxZ = 115; // Maximum Z coordinate of the walls\r\n    for (let i = 0; i < number + 1; i++) {\r\n\r\n        // Generate random positions within the boundaries of the walls\r\n        const randomX = Math.random() * (maxX - minX) + minX;\r\n        const randomZ = Math.random() * (maxZ - minZ) + minZ;\r\n    \r\n        \r\n        const position = new Vector3(randomX, 0.1, randomZ);\r\n    \r\n        \r\n        const enemyTypes = [Mutant, SkeletonZombie, Warrok];\r\n    \r\n       \r\n        const EnemyClass = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];\r\n    \r\n       \r\n        const enemy = new EnemyClass(this.scene, this.level);\r\n        await enemy.CreateMonster(position);\r\n    \r\n        // Add the enemy to the list of enemies in the first-person controller\r\n        this.level.firstPersonController.enemies.push(enemy);\r\n    }\r\n    \r\n}\r\n\r\n\r\nstartAddGeneration() {\r\n    const GENERATE_ADDS_INTERVAL = 45000;\r\n    this.generateAddsInterval = setInterval(() => {\r\n        this.generateAdds(5); \r\n    }, GENERATE_ADDS_INTERVAL);\r\n}\r\n\r\n\r\n\r\nduplicate(container: AssetContainer, position: Vector3) {\r\n   \r\n\r\n    \r\n    const entries = container.instantiateModelsToScene(undefined, false, { doNotInstantiate: true });\r\n    console.log(entries);\r\n    this.rootMesh = entries.rootNodes[0] as AbstractMesh;\r\n    this.mesh = entries.rootNodes[0].getChildMeshes()[0]; \r\n    this.rootMesh.setEnabled(true);\r\n    this.mesh.setEnabled(true);\r\n    for (const node of entries.rootNodes) {\r\n     if(node instanceof TransformNode) {\r\n         node.position = position;\r\n     }\r\n     \r\n }\r\n \r\n return entries;\r\n }\r\n \r\n}","import { AbstractMesh, Vector3, Scene, SceneLoader, FreeCamera, Sound, Mesh, StandardMaterial, MeshBuilder, GlowLayer, Color3 } from \"@babylonjs/core\";\r\n\r\nexport class TorchPowerup {\r\n\r\n    mesh: AbstractMesh | null;\r\n    scene!: Scene;\r\n    camera!: FreeCamera; \r\n    pickupSound: Sound;\r\n    glowLayer: GlowLayer;\r\n    scoreValue: number;\r\n\r\n    meshes: any;\r\n\r\n    constructor(scene: Scene, camera: FreeCamera) {\r\n        this.mesh = null;\r\n        this.scene = scene;\r\n        this.scoreValue = 100;\r\n        this.pickupSound = new Sound(\r\n            \"\",\r\n            \"./audio/pickups/torch.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                volume: 2,\r\n                autoplay: false\r\n            }\r\n        );\r\n       this.camera = camera;\r\n        this.glowLayer = new GlowLayer(\"glow\", this.scene);\r\n        this.glowLayer.intensity = 1; \r\n    }\r\n\r\n    async CreateTorchPowerup(position: Vector3) {\r\n      \r\n        const sphereCollider = MeshBuilder.CreateSphere(\"sphereCollider\", {diameter: 0.1}, this.scene);\r\n        sphereCollider.isVisible = false; \r\n        sphereCollider.visibility = 0.5;\r\n        sphereCollider.isPickable = false; \r\n        sphereCollider.checkCollisions = true;\r\n        sphereCollider.scaling = new Vector3(15, 1, 15); \r\n\r\n        sphereCollider.position = position.clone(); \r\n        sphereCollider.position.y += 0.1;\r\n\r\n\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/pickups/', 'torch.glb');\r\n        this.mesh = meshes[0]; \r\n        this.mesh.scaling = new Vector3(0.3, 0.3, 0.3);\r\n        this.mesh.position = position; \r\n\r\n\r\n        //this.meshes = meshes;\r\n\r\n  \r\n\r\n      \r\n        const glowMaterial = new StandardMaterial(\"glowMaterial\", this.scene);\r\n        glowMaterial.emissiveColor = new Color3(1, 1, 1); \r\n        glowMaterial.alpha = 0.5; \r\n        this.mesh.material = glowMaterial;\r\n\r\n        \r\n        this.mesh.setParent(sphereCollider);\r\n\r\n       \r\n        sphereCollider.id = \"torchPowerup\";\r\n\r\n\r\n       \r\n        setTimeout(() => {\r\n            sphereCollider.dispose();\r\n        }, 20000);\r\n    }\r\n\r\n    collectTorch() {\r\n        if (this.mesh && this.mesh.parent) {\r\n           \r\n            this.mesh.parent.dispose();\r\n            this.mesh = null;\r\n        }\r\n    }\r\n\r\n\r\n    checkFrustumVisibility(): void {\r\n        if(this.meshes) {\r\n       \r\n        this.meshes.forEach((mesh: Mesh) => {\r\n            if(mesh){\r\n            if (!this.camera.isInFrustum(mesh)) {\r\n                mesh.isVisible = false;\r\n            } else {\r\n                mesh.isVisible = true;\r\n            }\r\n        }\r\n        });\r\n    }\r\n}\r\n}\r\n","import { AbstractMesh, Vector3, Scene, SceneLoader, FreeCamera, Sound, Mesh, StandardMaterial, MeshBuilder, GlowLayer, Color3 } from \"@babylonjs/core\";\r\n\r\nexport class MedalPowerup {\r\n\r\n    mesh: AbstractMesh | null;\r\n    scene!: Scene;\r\n    camera!: FreeCamera; \r\n    pickupSound: Sound;\r\n    glowLayer: GlowLayer;\r\n    scoreValue: number;\r\n    meshes: any;\r\n\r\n    constructor(scene: Scene, camera: FreeCamera) {\r\n        this.mesh = null;\r\n        this.scene = scene;\r\n        this.scoreValue = 100;\r\n        this.camera = camera;\r\n        this.pickupSound = new Sound(\r\n            \"\",\r\n            \"./audio/pickups/ammobox.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n       \r\n        this.glowLayer = new GlowLayer(\"glow\", this.scene);\r\n        this.glowLayer.intensity = 2; \r\n    }\r\n\r\n    async CreateMedalPowerup(position: Vector3) {\r\n        \r\n        const sphereCollider = MeshBuilder.CreateSphere(\"sphereCollider\", {diameter: 0.1}, this.scene);\r\n        sphereCollider.isVisible = false;\r\n        sphereCollider.visibility = 0.5;\r\n        sphereCollider.isPickable = false;\r\n        sphereCollider.scaling = new Vector3(28, 1, 28); \r\n        sphereCollider.position = position.clone(); \r\n        sphereCollider.checkCollisions = true;\r\n        //sphereCollider.position.y += 1;\r\n\r\n        const { meshes } = await SceneLoader.ImportMeshAsync('', './models/pickups/', 'medal.glb');\r\n        this.mesh = meshes[0]; \r\n        this.mesh.scaling = new Vector3(0.3, 0.3, 0.3);\r\n        this.mesh.position = position; \r\n\r\n       /*  this.meshes = meshes; */\r\n\r\n\r\n\r\n        \r\n        const glowMaterial = new StandardMaterial(\"glowMaterial\", this.scene);\r\n        glowMaterial.emissiveColor = new Color3(1, 1, 1); \r\n        glowMaterial.alpha = 0.5; \r\n        this.mesh.material = glowMaterial;\r\n\r\n       \r\n        this.mesh.setParent(sphereCollider);\r\n\r\n        \r\n        sphereCollider.id = \"medalPowerup\";\r\n\r\n        setTimeout(() => {\r\n            sphereCollider.dispose();\r\n        }, 20000);\r\n    }\r\n\r\n    collectMedal() {\r\n        if (this.mesh && this.mesh.parent) {\r\n          \r\n            this.mesh.parent.dispose();\r\n            this.mesh = null;\r\n        }\r\n    }\r\n\r\n\r\n    checkFrustumVisibility(): void {\r\n        if(this.meshes) {\r\n       \r\n        this.meshes.forEach((mesh: Mesh) => {\r\n            if(mesh){\r\n            if (!this.camera.isInFrustum(mesh)) {\r\n                mesh.isVisible = false;\r\n            } else {\r\n                mesh.isVisible = true;\r\n            }\r\n        }\r\n        });\r\n    }\r\n}\r\n}\r\n","import { AbstractMesh, Scene, SceneLoader, Tags } from \"@babylonjs/core\";\r\n\r\nexport class Instances {\r\n    scene: Scene;\r\n\r\n    mutantRoot: any;\r\n    mutantMesh: any;\r\n    mutantSkeleton: any;\r\n    mutantAnim: any;\r\n\r\n    mutantAssetContainer: any;\r\n    warrokAssetContainer: any;\r\n    skeletonZombieAssetContainer: any;\r\n    bossAssetContainer: any;\r\n\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n        this.CreateMutant();\r\n        this.CreateWarrok();\r\n        this.CreateSkeletonZombie();\r\n        this.CreateBoss();\r\n    }\r\n\r\n\r\n    async CreateMutant() {\r\n\r\n\r\n        this.mutantAssetContainer = await SceneLoader.LoadAssetContainerAsync(\"./models/\", \"mutant2.glb\", this.scene);\r\n        this.mutantAssetContainer.addAllToScene();\r\n\r\n        this.mutantAssetContainer.meshes.forEach((mesh: AbstractMesh) => {\r\n            mesh.setEnabled(false); \r\n           \r\n        });\r\n\r\n    }\r\n\r\n\r\n    async CreateWarrok() {\r\n\r\n\r\n        this.warrokAssetContainer = await SceneLoader.LoadAssetContainerAsync(\"./models/\", \"warrokk.glb\", this.scene);\r\n        this.warrokAssetContainer.addAllToScene();\r\n\r\n        this.warrokAssetContainer.meshes.forEach((mesh: AbstractMesh) => {\r\n            mesh.setEnabled(false); \r\n           \r\n        });\r\n\r\n    }\r\n\r\n\r\n    async CreateSkeletonZombie() {\r\n\r\n\r\n        this.skeletonZombieAssetContainer = await SceneLoader.LoadAssetContainerAsync(\"./models/\", \"skelezombie.glb\", this.scene);\r\n        this.skeletonZombieAssetContainer.addAllToScene();\r\n\r\n        this.skeletonZombieAssetContainer.meshes.forEach((mesh: AbstractMesh) => {\r\n            mesh.setEnabled(false); \r\n           \r\n        });\r\n\r\n    }\r\n\r\n    async CreateBoss() {\r\n        this.bossAssetContainer = await SceneLoader.LoadAssetContainerAsync(\"./models/\", \"maw.glb\", this.scene);\r\n        this.bossAssetContainer.addAllToScene();\r\n\r\n        this.bossAssetContainer.meshes.forEach((mesh: AbstractMesh) => {\r\n            mesh.setEnabled(false);\r\n        })\r\n    }\r\n}","import { Scene, SceneLoader, Mesh, HemisphericLight, CubeTexture, Engine, Vector3, MeshBuilder, StandardMaterial, Color3, Sound, PBRMaterial, Texture, CannonJSPlugin , PhysicsImpostor, PointLight, ShadowGenerator, DirectionalLight, Light, LightGizmo, GizmoManager, ICullable, AbstractMesh, Gizmo} from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Mutant } from \"./Mutant\";\r\nimport * as CANNON from \"cannon\";\r\nimport { FirstPersonController } from \"./FirstPersonController\";\r\nimport { WeaponPickups } from \"./WeaponPickups\";\r\nimport { Weapon } from \"./Weapon\";\r\nimport { AmmoPickup } from \"./AmmoPickup\";\r\nimport { FirstAidPickup } from \"./FirstAidPickup\";\r\nimport { Warrok } from \"./Warrok\";\r\nimport { Boss } from \"./Boss\";\r\nimport { SkeletonZombie } from \"./SkeletonZombie\";\r\nimport { TorchPowerup } from \"./TorchPowerup\";\r\nimport { MedalPowerup } from \"./MedalPowerup\";\r\nimport { Instances } from \"./Instances\";\r\nimport HavokPhysics from \"@babylonjs/havok\";\r\n\r\n\r\nexport class Level {\r\n    scene: Scene;\r\n    enemies!: Enemy[];\r\n    engine: Engine;\r\n    firstPersonController: FirstPersonController;\r\n    waveIntervalId: number | undefined; // Store the interval ID\r\n\r\n    waveNumber!: number;\r\n    nextWaveTime: number;\r\n\r\n    enemyNumber!: number;\r\n    weaponPickups: WeaponPickups;\r\n    firstaid: FirstAidPickup;\r\n    ammopickup: AmmoPickup;\r\n    torchPowerup: any;\r\n    medalPowerup: MedalPowerup;\r\n\r\n    meshes: any;\r\n    instances!: Instances;\r\n    shadowGen!: ShadowGenerator;\r\n\r\n\r\n\r\n    constructor(engine: Engine, firstPersonController: FirstPersonController) {\r\n        this.engine = engine;\r\n\r\n        this.scene = this.CreateScene();\r\n        this.firstPersonController = firstPersonController;\r\n\r\n        this.waveNumber = 0;\r\n        this.nextWaveTime = 60;\r\n\r\n        this.engine.displayLoadingUI();\r\n        this.CreateEnvironment();\r\n        this.CreateImpostors();\r\n\r\n        this.createWall(new Vector3(-35, 0, -13));\r\n         this.createWall(new Vector3(-35, 0, 122));\r\n\r\n\r\n        this.createHWall(new Vector3(12,0,55));\r\n        this.createHWall(new Vector3(-82,0,55));\r\n\r\n\r\n        //this.CreateTorch();\r\n\r\n        this.weaponPickups = new WeaponPickups();\r\n        this.ammopickup = new AmmoPickup(this.scene, this.firstPersonController.camera);\r\n        this.firstaid = new FirstAidPickup(this.scene, this.firstPersonController.camera);\r\n        \r\n        this.torchPowerup = new TorchPowerup(this.scene, this.firstPersonController.camera);\r\n        this.medalPowerup = new MedalPowerup(this.scene, this.firstPersonController.camera);\r\n\r\n        this.instances = new Instances(this.scene);\r\n       \r\n  \r\n    }\r\n\r\n    async  getInitializedHavok() {\r\n        return await HavokPhysics();\r\n    }\r\n\r\n\r\n    CreateScene(): Scene {\r\n        const scene = new Scene(this.engine);\r\n    \r\n      /*   const hemilight = new HemisphericLight(\"hemi\", new Vector3(0,1,0), this.scene);\r\n    \r\n        hemilight.intensity = 0.3;\r\n        //const light = new PointLight(\"pointLight\", new Vector3(75, 50, -70), scene)\r\n        const light = new DirectionalLight(\"DirectionalLight\", new Vector3(-1, -1, -0.75), scene); */\r\n\r\n        const envTex = CubeTexture.CreateFromPrefilteredData(\r\n            \"./environment/environment.env\",\r\n            scene\r\n          );\r\n\r\n          \r\n      /*     light.intensity = 3; */\r\n          //light.position = new Vector3(0,10,0);\r\n    /*       light.shadowEnabled = true;\r\n          light.shadowMinZ = 1;\r\n          light.shadowMaxZ = 10;  */\r\n\r\n       //this.CreateGizmos(light);\r\n\r\n       /*    const shadowGen = new ShadowGenerator(2048, light); */\r\n          /* shadowGen.useBlurCloseExponentialShadowMap = true; */\r\n      \r\n         scene.environmentTexture = envTex;\r\n      \r\n          scene.createDefaultSkybox(envTex, true);\r\n      \r\n          scene.environmentIntensity = 0.7;\r\n          \r\n          const hemi = new DirectionalLight(\"hemi\", new Vector3(0,-1,0), this.scene);\r\n          hemi.intensity = 0.1;\r\n\r\n\r\n          const light = new DirectionalLight(\"DirectionalLight\", new Vector3(-2, -1.5, -2), this.scene);\r\n          //const light = new PointLight(\"PointLight\", new Vector3(-35,10,55), this.scene);\r\n          //light.position = new Vector3(0,10,0);\r\n          light.intensity = 3.5;\r\n          light.shadowEnabled = true;\r\n          light.autoUpdateExtends = true;\r\n          light.autoCalcShadowZBounds= true;\r\n          \r\n       \r\n\r\n\r\n           this.shadowGen = new ShadowGenerator(1024, light);\r\n          //this.shadowGen.useBlurCloseExponentialShadowMap = true; \r\n          this.shadowGen.useBlurCloseExponentialShadowMap = true;\r\n          //this.shadowGen.useContactHardeningShadow = true;\r\n          //this.shadowGen.usePercentageCloserFiltering = true;\r\n        //  this.shadowGen.filteringQuality = 64;\r\n         // this.CreateLights();\r\n        //this.shadowGen.forceBackFacesOnly = true;\r\n        this.shadowGen.useKernelBlur = true;\r\n        this.shadowGen.blurKernel = 64;\r\n        this.shadowGen.blurScale = 1;\r\n       // this.shadowGen.usePoissonSampling = true;\r\n        //this.shadowGen.useContactHardeningShadow = true;\r\n        //\r\n        \r\n          scene.enablePhysics(new Vector3(0,-9.81,0), new CannonJSPlugin(true, 10, CANNON));\r\n    \r\n    \r\n    \r\n        \r\n        scene.collisionsEnabled = true;\r\n    \r\n        return scene;\r\n      }\r\n      CreateAsphalt(): PBRMaterial {\r\n        const pbr = new PBRMaterial(\"pbr\", this.scene);\r\n    \r\n        // Albedo texture\r\n        const albedoTexture = new Texture(\"./textures/grass/grass_diff.png\", this.scene);\r\n        albedoTexture.uScale = 200;\r\n        albedoTexture.vScale = 200;\r\n        pbr.albedoTexture = albedoTexture;\r\n    \r\n        // Bump texture\r\n        const bumpTexture = new Texture(\"./textures/grass/grass_norm.png\", this.scene);\r\n        bumpTexture.uScale = 200;\r\n        bumpTexture.vScale = 200;\r\n\r\n        pbr.bumpTexture = bumpTexture;\r\n        pbr.invertNormalMapX = true;\r\n        pbr.invertNormalMapY = true;\r\n    \r\n        // Metallic texture\r\n        const metallicTexture = new Texture(\"./textures/grass/grass_arm.jpg\", this.scene);\r\n        metallicTexture.uScale = 200;\r\n        metallicTexture.vScale = 200;\r\n        \r\n        pbr.metallicTexture = metallicTexture;\r\n    \r\n        pbr._useAmbientOcclusionFromMetallicTextureRed = true;\r\n        pbr.useRoughnessFromMetallicTextureGreen = true;\r\n        pbr.useMetallnessFromMetallicTextureBlue = true;\r\n    \r\n        return pbr;\r\n    }\r\n    \r\n  \r\n      async CreateEnvironment(): Promise<void> {\r\n         \r\n        const { meshes } = await SceneLoader.ImportMeshAsync(\r\n                \"\",\r\n                \"./models/\",\r\n                \"stadetest8.glb\",\r\n                this.scene\r\n            );\r\n\r\n\r\n    \r\n\r\n        meshes.forEach((mesh) => {\r\n\r\n       \r\n        // Enable collisions\r\n        //mesh.checkCollisions = true;\r\n        mesh.isPickable = false; \r\n        this.shadowGen.addShadowCaster(mesh);\r\n\r\n      \r\n        mesh.receiveShadows = true;\r\n        \r\n\r\n\r\n        /* mesh.freezeWorldMatrix();\r\n        mesh.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY; */\r\n\r\n       // We remove non visible parts\r\n        if(mesh.name === \"Doors\"  || mesh.name === \"Stairs\" || mesh.name === \"Gates\" || \r\n        mesh.name === \"Entrance Steps\" || mesh.name ===\"End Terraces\" || mesh.name === \"Dividers\" || mesh.name === \"Doorknobs\" || mesh.name === \"Door Handles\" \r\n        || mesh.name ===\"Door Frames.\" || mesh.name === \"Ground Level\"\r\n        || mesh.name === \"Flag Pole Bases\" || mesh.name === \"Pressbox\" || mesh.name === \"Gates 02\" ) {\r\n        mesh.isVisible = false;\r\n       }\r\n\r\n       if(mesh.name === \"Fence\" || mesh.name===\"Lines\" || mesh.name === \"Plane.005\" || mesh.name===\"Ramps\") {\r\n        mesh.isPickable = true;\r\n        }\r\n      \r\n        \r\n     }); \r\n\r\n     this.meshes = meshes;\r\n    \r\n\r\n    \r\n      \r\n        const ground = MeshBuilder.CreateGround( \"ground\",\r\n        {width: 250, height: 250},\r\n        this.scene);\r\n\r\n        const groundMaterial = this.CreateAsphalt();\r\n\r\n       \r\n\r\n        ground.position = new Vector3(-35, 0.05, 55);\r\n      \r\n        ground.material = groundMaterial;\r\n                \r\n        \r\n        ground.checkCollisions = true; \r\n     //   this.shadowGen.addShadowCaster(ground);\r\n        ground.receiveShadows = true;\r\n        //ground.isVisible = false;\r\n\r\n        //ground.renderingGroupId = 0;\r\n\r\n         ground.physicsImpostor = new PhysicsImpostor(\r\n            ground,\r\n            PhysicsImpostor.BoxImpostor,\r\n            {mass:0, restitution:0}\r\n        ); \r\n        \r\n      \r\n \r\n\r\n     \r\n        //this.engine.setHardwareScalingLevel(1 / window.devicePixelRatio);\r\n\r\n     \r\n        //this.CreateTrack();\r\n\r\n         const backgroundMusic = new Sound(\r\n            \"backgroundMusic\",\r\n            \"./audio/background4.mp3\",\r\n            this.scene,\r\n            null, \r\n            {\r\n                volume: 0.01,\r\n                autoplay: true,\r\n                loop: true\r\n          }\r\n        );\r\n\r\n\r\n        //this.engine.hideLoadingUI();\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    async generateEnemies(number: number): Promise<void> {\r\n        this.waveNumber+=1;\r\n\r\n        const minX = -81; \r\n        const maxX = 11;\r\n        const minZ = -7; \r\n        const maxZ = 114; \r\n   \r\n\r\n        if(this.waveNumber  == 2) {\r\n            this.firstPersonController.inventory.push(this.firstPersonController.rifle);\r\n            this.weaponPickups.CreateRiflePickup(new Vector3(Math.random() * (maxX - minX) + minX,0.1,Math.random() * (maxZ - minZ) + minZ));\r\n           \r\n        }\r\n\r\n        if(this.waveNumber == 4) {\r\n            this.firstPersonController.inventory.push(this.firstPersonController.lmg);\r\n            this.weaponPickups.CreateLMGPickup(new Vector3(Math.random() * (maxX - minX) + minX,0.1,Math.random() * (maxZ - minZ) + minZ));\r\n        }\r\n\r\n        if(this.waveNumber == 7) {\r\n            this.firstPersonController.inventory.push(this.firstPersonController.minigun);\r\n            this.weaponPickups.CreateMinigunPickup(new Vector3(Math.random() * (maxX - minX) + minX,0.1,Math.random() * (maxZ - minZ) + minZ));\r\n        }\r\n\r\n\r\n\r\n        for (let i = 0; i < number + 2; i++) {\r\n      \r\n    \r\n          \r\n            const randomX = Math.random() * (maxX - minX) + minX;\r\n            const randomZ = Math.random() * (maxZ - minZ) + minZ;\r\n    \r\n           \r\n            const position = new Vector3(randomX, 0.1, randomZ);\r\n            const mutant = new Mutant(this.scene, this);\r\n            await mutant.CreateMonster(position);\r\n    \r\n            this.firstPersonController.enemies.push(mutant);\r\n        }\r\n\r\n\r\n\r\n        if(this.waveNumber >= 2) {\r\n            for (let i = 0; i < number -2 + 1; i++) {\r\n      \r\n    \r\n               \r\n                const randomX = Math.random() * (maxX - minX) + minX;\r\n                const randomZ = Math.random() * (maxZ - minZ) + minZ;\r\n        \r\n             \r\n                const position = new Vector3(randomX, 0.1, randomZ);\r\n                const warrok = new Warrok(this.scene, this);\r\n                await warrok.CreateMonster(position);\r\n        \r\n                this.firstPersonController.enemies.push(warrok);\r\n            }\r\n        }\r\n\r\n\r\n\r\n        if(this.waveNumber >= 4) {\r\n            for (let i = 0; i < number -2 + 1; i++) {\r\n      \r\n    \r\n               \r\n                const randomX = Math.random() * (maxX - minX) + minX;\r\n                const randomZ = Math.random() * (maxZ - minZ) + minZ;\r\n        \r\n               \r\n                const position = new Vector3(randomX, 0.1, randomZ);\r\n                const skeletonZombie = new SkeletonZombie(this.scene, this);\r\n                await skeletonZombie.CreateMonster(position);\r\n        \r\n                this.firstPersonController.enemies.push(skeletonZombie);\r\n        }\r\n    }\r\n\r\n\r\n    if(this.waveNumber === 8) {\r\n        this.stopWaveSystem();\r\n        this.nextWaveTime=0;\r\n\r\n       \r\n        const randomX = Math.random() * (maxX - minX) + minX;\r\n        const randomZ = Math.random() * (maxZ - minZ) + minZ;\r\n\r\n       \r\n        const position = new Vector3(randomX, 0.1, randomZ);\r\n        const boss = new Boss(this.scene, this.firstPersonController.player, this);\r\n        await boss.CreateMonster(position);\r\n\r\n        this.firstPersonController.enemies.push(boss);\r\n    }\r\n}\r\n    \r\n\r\n    startWaveSystem(): void {\r\n        \r\n        this.waveIntervalId = setInterval(() => {\r\n            this.generateEnemies(this.waveNumber);\r\n            this.nextWaveTime = 60;\r\n        }, 60000);\r\n\r\n\r\n\r\n        setInterval(() => {\r\n            if (this.nextWaveTime > 0) {\r\n                this.nextWaveTime -= 1;\r\n            }\r\n        }, 1000);\r\n    \r\n    \r\n    \r\n        this.startPickupGeneration();\r\n    \r\n    }\r\n\r\n    stopWaveSystem(): void {\r\n       \r\n        if (this.waveIntervalId !== undefined) {\r\n            clearInterval(this.waveIntervalId);\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    startPickupGeneration(): void {\r\n        \r\n\r\n        const minX = -82; \r\n        const maxX = 12;\r\n        const minZ = -8; \r\n        const maxZ = 115; \r\n\r\n\r\n        const minY = 0.1;\r\n        const maxY = 0.2;\r\n   \r\n\r\n        setInterval(() => {\r\n            this.ammopickup.CreateAmmoPickup(new Vector3(Math.random() * (maxX - minX) + minX,0.1,Math.random() * (maxZ - minZ) + minZ));\r\n        }, 60000); \r\n\r\n\r\n        setInterval(() => {\r\n            this.firstaid.CreateFirstAidPickup(new Vector3(Math.random() * (maxX - minX) + minX,0.1,Math.random() * (maxZ - minZ) + minZ));\r\n        }, 60000); \r\n\r\n\r\n\r\n        \r\n\r\n        setInterval(() => {\r\n            this.torchPowerup.CreateTorchPowerup(new Vector3(Math.random() * (maxX - minX) + minX,\r\n            Math.random() * (maxY - minY) + minY,\r\n            Math.random() * (maxZ - minZ) + minZ));\r\n          }, 20000); \r\n\r\n\r\n        setInterval(() => {\r\n            this.medalPowerup.CreateMedalPowerup(new Vector3(Math.random() * (maxX - minX) + minX,\r\n            Math.random() * (maxY - minY) + minY,\r\n            Math.random() * (maxZ - minZ) + minZ));\r\n        }, 20000); \r\n\r\n\r\n\r\n    }\r\n\r\n\r\n    createWall(position: Vector3): void {\r\n        \r\n        const wallWidth = 95;\r\n        const wallHeight = 5;\r\n        const wallDepth = 0.5;\r\n        const wallPosition = position; \r\n\r\n       \r\n        const wall = MeshBuilder.CreateBox(\"wall\", { width: wallWidth, height: wallHeight, depth: wallDepth }, this.scene);\r\n\r\n       \r\n        wall.position = wallPosition;\r\n\r\n       \r\n        const wallMaterial = new StandardMaterial(\"wallMaterial\", this.scene);\r\n        wallMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5); \r\n        wall.material = wallMaterial;\r\n\r\n        wall.physicsImpostor = new PhysicsImpostor(\r\n            wall,\r\n            PhysicsImpostor.BoxImpostor,\r\n            { mass: 0, restitution: 0, friction: 0 },\r\n            this.scene\r\n        );\r\n       \r\n        wall.checkCollisions = true;\r\n      \r\n\r\n        wall.isVisible = false;\r\n        \r\n    }\r\n      \r\n    createHWall(position: Vector3): void {\r\n      \r\n        const wallWidth = 135;\r\n        const wallHeight = 15;\r\n        const wallDepth = 0.5;\r\n        const wallPosition = position; \r\n\r\n        \r\n        const wall = MeshBuilder.CreateBox(\"wall\", { width: wallWidth, height: wallHeight, depth: wallDepth }, this.scene);\r\n\r\n       \r\n        wall.position = wallPosition;\r\n        wall.rotation.y = Math.PI/2;\r\n\r\n       \r\n        const wallMaterial = new StandardMaterial(\"wallMaterial\", this.scene);\r\n        wallMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5); \r\n        wall.material = wallMaterial;\r\n\r\n        wall.physicsImpostor = new PhysicsImpostor(\r\n            wall,\r\n            PhysicsImpostor.BoxImpostor,\r\n            { mass: 0, restitution: 0, friction: 0 },\r\n            this.scene\r\n        );\r\n        \r\n        wall.checkCollisions = true;\r\n       \r\n        wall.isVisible = false;\r\n        \r\n    }\r\n\r\n    async CreateTorch() {\r\n        const { meshes, animationGroups } = await SceneLoader.ImportMeshAsync(\"\", \"./models/pickups/\", \"torch.glb\");\r\n        meshes[0].position = new Vector3(-25, 0.5, 50);\r\n    }\r\n\r\n    CreateImpostors(): void {\r\n         const ground = MeshBuilder.CreateGround(\"groundImpostor\", {width:200, height:200 });\r\n         ground.isVisible = false;\r\n         ground.position.y += 0.05;\r\n          ground.physicsImpostor = new PhysicsImpostor(\r\n             ground,\r\n             PhysicsImpostor.BoxImpostor,\r\n             {mass:0, restitution:0}\r\n         ); \r\n\r\n         \r\n         this.firstPersonController.ground = ground;\r\n\r\n   \r\n\r\n        \r\n     }\r\n\r\n\r\n     async CreateTrack() {\r\n        const {meshes} = await SceneLoader.ImportMeshAsync(\r\n            \"\",\r\n             \"./models/\",\r\n             \"runtrack.glb\",\r\n             this.scene\r\n         );\r\n\r\n         meshes.forEach((mesh) => {\r\n            \r\n           \r\n            // Enable collisions\r\n            //mesh.checkCollisions = true;\r\n            mesh.receiveShadows = true;\r\n            mesh.position.y = 0.9\r\n            //mesh.isVisible = false;\r\n         }); \r\n     }\r\n\r\n     checkFrustumVisibility(): void {\r\n        if(this.meshes) {\r\n        \r\n        this.meshes.forEach((mesh: Mesh) => {\r\n            if (!this.firstPersonController.camera.isInFrustum(mesh)) {\r\n                mesh.isVisible = false;\r\n            } else {\r\n                mesh.isVisible = true;\r\n            }\r\n        });\r\n    }\r\n    }\r\n\r\n\r\n    CreateLights() {\r\n        const light = new DirectionalLight(\"DirectionalLight\", new Vector3(-1, -2, -1), this.scene);\r\n\r\n       /*  hemiLight.diffuse = new Color3(1,0,0);\r\n        hemiLight.groundColor = new Color3(0,0,1); */\r\n\r\n        //this.CreateGizmos(hemiLight);\r\n    }\r\n\r\n\r\n    CreateGizmos(customLight: Light): void {\r\n\r\n        const lightGizmo = new LightGizmo();\r\n        lightGizmo.scaleRatio = 2;\r\n        lightGizmo.light= customLight;\r\n\r\n  // Create a dummy mesh to attach the gizmo\r\n        const dummyMesh = new Mesh(\"dummyMesh\", this.scene);\r\n\r\n        dummyMesh.position = new Vector3(-30, 2, 65)\r\n        lightGizmo.attachedMesh = dummyMesh;\r\n\r\n\r\n        const gizmoManager = new GizmoManager(this.scene);\r\n        gizmoManager.positionGizmoEnabled = true;\r\n\r\n        gizmoManager.rotationGizmoEnabled = true;\r\n\r\n        gizmoManager.usePointerToAttachGizmos = false;\r\n\r\n        gizmoManager.attachToMesh(dummyMesh);\r\n    }\r\n\r\n}","\r\nimport { AbstractMesh, Animation, AnimationGroup, Color3, FreeCamera, Material, Mesh, MeshBuilder, PBRMaterial, Ray, Scene, SceneLoader, Sound, StandardMaterial, Tags, Texture, TransformNode, Vector3, ParticleSystem, Color4 } from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\n\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Player } from \"./Player\";\r\n\r\nexport class Weapon {\r\n\r\n    camera: FreeCamera;\r\n    scene: Scene;\r\n    animationGroups!: AnimationGroup[];\r\n    isFiring: boolean;\r\n    isReloading: boolean;\r\n    gunMesh!: any;\r\n    gunMeshChild!: any;\r\n    ammo: number;\r\n    reloadAmmo: number;\r\n    enemies: Enemy[];\r\n    bulletHoleMaterial!: PBRMaterial;\r\n\r\n\r\n    shootSound!: Sound;\r\n    emptySound!: Sound;\r\n    reloadSound!: Sound;\r\n    readySound!: Sound;\r\n\r\n\r\n    isMeshCreated!: boolean;\r\n\r\n    toggleAutomatic!: boolean;\r\n    fireRate!: number;\r\n\r\n     muzzleFlashParticleSystem: ParticleSystem | null = null;\r\n     isShootingAnimationPlaying: boolean;\r\n\r\n     isReadying: boolean;\r\n\r\n    damage: number;\r\n\r\n     player!: Player;\r\n    canvas: HTMLCanvasElement;\r\n\r\n    constructor(scene: Scene, camera: FreeCamera, enemies: Enemy[], player: Player, canvas: HTMLCanvasElement) {\r\n        this.camera = camera;\r\n        this.scene = scene;\r\n        this.player = player;\r\n\r\n        this.canvas = canvas;\r\n\r\n        this.isFiring = false;\r\n        this.isReloading = false;\r\n        this.isReadying = false;\r\n        this.ammo = 30;\r\n        this.enemies = enemies;\r\n        this.reloadAmmo = 90;\r\n        this.loadBulletholes();\r\n\r\n\r\n        this.fireRate = 100;\r\n\r\n\r\n        this.damage = 15;\r\n    \r\n        this.isShootingAnimationPlaying = false;\r\n        \r\n    }\r\n\r\n\r\n    async CreateG(): Promise<void> {\r\n      \r\n\r\n        const {meshes, animationGroups} = await SceneLoader.ImportMeshAsync('', './models/', 'rifle.glb');\r\n\r\n        this.gunMeshChild = meshes[1];\r\n    \r\n      \r\n        const transformNode = new TransformNode('glb');\r\n        \r\n\r\n       \r\n            meshes[0].parent = transformNode;\r\n            meshes[0].isVisible = true;\r\n            meshes[0].renderingGroupId = 100;\r\n            this.gunMesh = meshes[0];\r\n\r\n\r\n            const start = 190;\r\n            const end = 250;\r\n           \r\n            this.animationGroups = animationGroups;\r\n            animationGroups.forEach(function (animationGroup) {\r\n                animationGroup.stop();\r\n       \r\n                \r\n                animationGroup.start(true, 0.3, 397, 458); //\r\n              \r\n               \r\n\r\n               \r\n            });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        transformNode.parent = this.camera;\r\n\r\n        transformNode.position.y -= 0.2;\r\n        transformNode.position.z += 0.60;\r\n        transformNode.position.x += 0.32;\r\n        \r\n        \r\n        transformNode.scaling.set(0.01,0.01,0.01);\r\n   \r\n\r\n\r\n        this.CreateCrosshair();\r\n\r\n\r\n        \r\n        this.shootSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/shoot.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.shootSound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.emptySound = new Sound(\r\n            \"emptySound\",\r\n            \"./audio/empty.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.emptySound.attachToMesh(this.gunMesh);\r\n\r\n        this.reloadSound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/reload.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.reloadSound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.readySound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/weapons/readyRifle2.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.readySound.attachToMesh(this.gunMesh);\r\n\r\n\r\n        this.createMuzzleFlashParticleSystem();\r\n        this.isMeshCreated = true;\r\n\r\n       // this.scene.getEngine().hideLoadingUI();\r\n    }\r\n\r\n\r\n\r\n    CreateCrosshair(): Mesh {\r\n        const size = 1;\r\n        const plane = MeshBuilder.CreatePlane('crosshair',{size});\r\n        // plane.position.x= -size/2;\r\n        // plane.position.y= -size/2;\r\n        const material = new StandardMaterial('crossHairMaterial',this.scene);\r\n        plane.material = material;\r\n        const texture = new Texture('./textures/crosshair.png', this.scene);\r\n        material.diffuseTexture=texture;\r\n        material.diffuseColor=Color3.White();\r\n        material.opacityTexture = material.diffuseTexture\r\n        material.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n        material.alpha = 1\r\n        texture.hasAlpha = true;\r\n        plane.parent = this.camera;\r\n        plane.position.z = 1;\r\n        plane.scaling = new Vector3(0.3/4,0.3/4,0.3/4);\r\n        plane.checkCollisions = false;\r\n        plane.isPickable = false;\r\n        return plane;\r\n    }\r\n\r\n\r\n\r\n    \r\n    shootAnimation(gun: Weapon) {\r\n\r\n       \r\n        \r\n\r\n        gun.animationGroups.forEach( (animationGroup) => {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 0.85, 0, 16);\r\n    \r\n\r\n            gun.isFiring = true;\r\n\r\n\r\n        // Start the muzzle flash particle system when the shooting animation begins\r\n        if (gun.muzzleFlashParticleSystem) {\r\n            gun.muzzleFlashParticleSystem.start();\r\n            setTimeout(() => {\r\n                gun.muzzleFlashParticleSystem!.stop();\r\n            }, 10); \r\n\r\n           /*  // Update the position of the particle system on each frame\r\n            this.scene.onBeforeRenderObservable.add(() => {\r\n                // Update the position of the particle system to match the position of the gun mesh\r\n                this.muzzleFlashParticleSystem!.emitter = this.gunMesh;\r\n            }); */\r\n            \r\n        }\r\n\r\n    \r\n\r\n           \r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n               \r\n                \r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n    \r\n    idleAnimation(gun: Weapon) {\r\n        if(!this.player.isDead()) {\r\n        if (gun.isFiring || !gun.isReloading) {\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n                animationGroup.stop();\r\n                animationGroup.start(true, 0.3, 397, 458);\r\n            });\r\n            gun.isFiring = false; // Reset the flag\r\n        }\r\n    }\r\n    }\r\n\r\n\r\n    reloadAnimation(gun: Weapon) {\r\n        gun.isReloading = true;\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 16, 176);\r\n    \r\n          \r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n               \r\n                gun.isReloading = false;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n    readyAnimation(gun: Weapon) {\r\n        gun.animationGroups.forEach( (animationGroup) => {\r\n            animationGroup.stop();\r\n            //animationGroup.start(false, 1.25, 120, 176);\r\n            animationGroup.start(false, 1, 320, 396);\r\n\r\n\r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n               \r\n                \r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n\r\n    readySfx() {\r\n        this.readySound.play();\r\n    }\r\n\r\n    shoot(): void {\r\n        if (this.ammo > 0 && !this.isReloading) {\r\n\r\n            this.shootSound.play();\r\n            \r\n         \r\n            const deviationAngle = Math.random() * Math.PI * 2; // Random angle between 0 and 2*pi\r\n            const deviationAmount = Math.random() * 0.04; // Random deviation amount\r\n            const deviationVector = new Vector3(Math.cos(deviationAngle) * deviationAmount, 0, Math.sin(deviationAngle) * deviationAmount);\r\n            \r\n            \r\n            const rayDirection = this.camera.getForwardRay().direction.add(deviationVector);\r\n\r\n            // Create the picking ray from the center of the screen\r\n            const ray = this.scene.createPickingRay(\r\n                this.canvas.clientWidth / 2,\r\n                this.canvas.clientHeight / 2,\r\n                null,\r\n                this.camera\r\n            );\r\n        \r\n           \r\n            const raycastHit = this.scene.pickWithRay(ray);\r\n    \r\n          \r\n            if (raycastHit && raycastHit.hit) {\r\n              \r\n                if (Tags.MatchesQuery(raycastHit.pickedMesh!, \"enemy\")) {\r\n\r\n                \r\n                    const enemy = this.getEnemyFromMesh(raycastHit.pickedMesh!);\r\n                    if(enemy) {\r\n                    \r\n                    enemy!.health -= this.damage;\r\n\r\n                    //console.log(\"dead?\" , enemy!.states.DESTROYED);\r\n\r\n                    if (enemy!.health > 0) {\r\n                        // Play shot animation on the enemy\r\n                        this.playShotAnimation(enemy!);\r\n                       \r\n                    }\r\n    \r\n                    // Check if the enemy's HP has reached 0\r\n                    if (enemy!.health <= 0) {\r\n                        if(!enemy!.states.DESTROYED) {\r\n                            this.player.score += enemy!.scoreValue;\r\n                        // Play death animation if the enemy is killed\r\n                        this.playDeathAnimation(enemy!);\r\n\r\n                        enemy!.death.onAnimationEndObservable.addOnce(()=>{\r\n                            \r\n                            if(enemy) {\r\n\r\n                            // this array\r\n                            const index = this.enemies.indexOf(enemy!);\r\n                         \r\n                            if (index !== -1) {\r\n                                \r\n                                this.enemies.splice(index, 1);\r\n                            }\r\n\r\n\r\n                            // fps array\r\n                            const indexFPS = this.player.firstPersonController.enemies.indexOf(enemy);\r\n                            if (indexFPS !== -1) {\r\n                                \r\n                                this.player.firstPersonController.enemies.splice(indexFPS, 1);\r\n                            }\r\n\r\n\r\n\r\n\r\n\r\n                          \r\n\r\n                        }\r\n\r\n\r\n\r\n\r\n                        });\r\n\r\n\r\n\r\n                        //this.player.score += 1;\r\n                        //console.log(\"Player Score\", this.player.score);\r\n                        //enemy.rootMesh!.physicsImpostor!.setLinearVelocity(new Vector3(0,0,0));\r\n\r\n                        enemy!.states.DESTROYED = true;\r\n                        }\r\n                    }\r\n                }\r\n    \r\n            }\r\n                // Create a decal to indicate the impact of the shot\r\n                const size = 0.1;\r\n                const decal = MeshBuilder.CreateDecal(\"decal\", raycastHit.pickedMesh!, {\r\n                    position: raycastHit.pickedPoint!,\r\n                    normal: raycastHit.getNormal(true)!,\r\n                    size: new Vector3(size, size, size)\r\n                });\r\n                decal.material = this.bulletHoleMaterial;\r\n                //console.log(\"Raycast hit something\");\r\n// Dispose of the decal after 10 seconds\r\n                    setTimeout(() => {\r\n                        decal.dispose();\r\n                    }, 10000);\r\n                                \r\n                \r\n            }\r\n    \r\n            // Reduce ammo count and update UI\r\n            this.ammo -= 1;\r\n            // this.updateAmmoText(); \r\n        }\r\n    }\r\n    \r\n\r\n\r\n    reloadWeapon() {\r\n        const remainingAmmo = this.ammo;\r\n        const reloadAmount = Math.min(30 - remainingAmmo, this.reloadAmmo);\r\n        this.ammo += reloadAmount;\r\n        this.reloadAmmo -= reloadAmount;\r\n        //this.updateAmmoText();\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n    \r\n\r\n\r\n\r\n    playShotAnimation(enemy: Enemy): void {\r\n        // Trigger shot animation on the enemy that was hit\r\n        enemy.shotAnimation();\r\n    }\r\n    playDeathAnimation(enemy: Enemy): void {\r\n        // Trigger death animation on the enemy that was hit\r\n        enemy.deathAnimation();\r\n    }\r\n\r\n\r\n    getEnemyFromMesh(mesh: AbstractMesh): Enemy | undefined {\r\n      \r\n        for (const enemy of this.enemies) {\r\n            if (enemy.mesh === mesh) {\r\n                return enemy;\r\n            }\r\n        }\r\n\r\n        return undefined; \r\n    }\r\n    \r\n\r\n    async loadBulletholes() {\r\n        this.bulletHoleMaterial = new PBRMaterial(\"bulletHoleMaterial\", this.scene);\r\n\r\n        \r\n        // Load the bullet hole texture\r\n       this.bulletHoleMaterial.albedoTexture = new Texture(\"textures/bullet_hole.png\", this.scene);\r\n\r\n        // Create a material with the bullet hole texture\r\n        \r\n        this.bulletHoleMaterial.albedoTexture.hasAlpha = true;\r\n        this.bulletHoleMaterial.zOffset = -0.25;\r\n        this.bulletHoleMaterial.roughness = 0.5;\r\n       //this.bulletHoleMaterial.zOffset = -0.25;\r\n        /* this.splatter = new PBRMaterial(\"greenSplatter\", this.scene);\r\n        this.splatter.roughness = 1;\r\n        this.splatter.albedoTexture = new Texture(\"textures/green.png\", this.scene);\r\n        this.splatter.albedoTexture.hasAlpha = true;\r\n*/\r\n      \r\n    \r\n}\r\n\r\ncreateMuzzleFlashParticleSystem(): void {\r\n    // Create particle system\r\n    this.muzzleFlashParticleSystem = new ParticleSystem(\"muzzleFlash\", 200, this.scene);\r\n    \r\n    // Set particle texture\r\n    const texture = new Texture(\"./textures/particles/muzzle_05.png\", this.scene);\r\n    texture._parentContainer = this.gunMesh;\r\n    this.muzzleFlashParticleSystem.particleTexture = texture;\r\n    \r\n    // Set particle system properties\r\n    this.muzzleFlashParticleSystem.emitter = this.gunMesh; // Set emitter to gun mesh\r\n    this.muzzleFlashParticleSystem.minEmitBox = new Vector3(15, 14, 100); \r\n    this.muzzleFlashParticleSystem.maxEmitBox = new Vector3(15, 14, 100); \r\n \r\n    \r\n    this.muzzleFlashParticleSystem.color1 = new Color4(0.8, 0.5, 0, 1); // Bright yellow-orange with 80% opacity\r\n    this.muzzleFlashParticleSystem.color2 = new Color4(0.8, 0.5, 0, 1); \r\n    this.muzzleFlashParticleSystem.colorDead = new Color4(1, 0.5, 0, 1); \r\n    \r\n       \r\n    this.muzzleFlashParticleSystem.minSize = 0.3;\r\n    this.muzzleFlashParticleSystem.maxSize = 0.6;\r\n    this.muzzleFlashParticleSystem.minLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.maxLifeTime = 0.01;\r\n    this.muzzleFlashParticleSystem.emitRate = 10;\r\n\r\n    \r\n\r\n    \r\n    \r\n\r\n    this.muzzleFlashParticleSystem.start();\r\n    this.muzzleFlashParticleSystem.stop(); \r\n\r\n\r\n    \r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ndispose(): void {\r\n    // Dispose of the gun mesh\r\n     // Dispose of the gun mesh and its children\r\n     if (this.gunMesh) {\r\n        this.gunMesh.dispose();\r\n        this.gunMesh = null;\r\n    }\r\n\r\n    // Optionally, set other properties to null or dispose of other objects\r\n}\r\n\r\n// Inside your Weapon class (or a superclass)\r\nasync preloadMesh(): Promise<void> {\r\n    if (!this.isMeshCreated) {\r\n        await this.CreateG(); // Create the mesh if it's not already created\r\n        if (this.gunMesh) {\r\n            this.gunMesh.setEnabled(false); // Hide the mesh\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","import { FreeCamera, Vector3, Animation, Scene, Sound } from \"@babylonjs/core\";\r\nimport { TextBlock } from \"@babylonjs/gui\";\r\nimport { FirstPersonController } from \"./FirstPersonController\";\r\n\r\nexport class Player {\r\n\r\n\r\n    health: number;\r\n    healthView!: TextBlock;\r\n    position!: Vector3;\r\n    maxHealth: number;\r\n    stamina: number;\r\n    maxStamina: number;\r\n\r\n    camera: FreeCamera;\r\n    scene: Scene;\r\n\r\n\r\n    score: number;\r\n\r\n    hasDot: boolean;\r\n\r\n    jumpingPower: number;\r\n\r\n\r\n    staminaRegenRate: number;\r\n    staminaDecayRate: number;\r\n\r\n\r\n    sprintSpeed: number;\r\n    walkSpeed: number;\r\n    firstPersonController: FirstPersonController;\r\n\r\n\r\n    isDecaying!: boolean;\r\n    isRegenerating!: boolean;\r\n\r\n    decayInterval!: number;\r\n    regenInterval!: number;\r\n\r\n\r\n    outOfBreath: Sound;\r\n\r\n    constructor(camera: FreeCamera, scene: Scene, firstPersonController: FirstPersonController) {\r\n\r\n        this.health = 100;\r\n        this.maxHealth = 100;\r\n        this.stamina = 100;\r\n        this.maxStamina = 100;\r\n        this.camera = camera;\r\n        this.scene = scene;\r\n        this.firstPersonController = firstPersonController;\r\n\r\n        this.hasDot = false;\r\n        this.score = 0;\r\n\r\n        this.jumpingPower = 5;\r\n\r\n        this.staminaRegenRate= 5;\r\n        this.staminaDecayRate = 10;\r\n\r\n        this.sprintSpeed = 3;\r\n        this.walkSpeed = 1.5;\r\n\r\n\r\n        this.outOfBreath = new Sound(\r\n            \"firstAidPickup\",\r\n            \"./audio/player/outofbreath.mp3\",\r\n            this.scene,\r\n            null,\r\n            {\r\n                //spatialSound:true,\r\n                volume: 1,\r\n                autoplay:false\r\n            });\r\n    }\r\n\r\n\r\n    updatePosition(camera: FreeCamera) {\r\n        this.position = camera.position\r\n    }\r\n\r\n    screenJerk(duration = 100, intensity = 5) {\r\n         // Create glow overlay element\r\n        const glowOverlay = document.createElement('div');\r\n        glowOverlay.id = 'glow-overlay';\r\n        document.body.appendChild(glowOverlay);\r\n\r\n        // Remove the glow overlay after the specified duration\r\n        setTimeout(() => {\r\n            document.body.removeChild(glowOverlay);\r\n        }, duration);\r\n    }\r\n    \r\n    isDead(): boolean {\r\n        return this.health <= 0;\r\n    }\r\n\r\n\r\n\r\n    applyDot(damage: number, duration: number) {\r\n        // Calculate damage per second\r\n        const damagePerSecond = damage;\r\n    \r\n        // Apply initial damage\r\n        //this.health -= damagePerSecond;\r\n    \r\n        this.hasDot = true;\r\n        // Create timer for the damage-over-time effect\r\n        const dotTimer = setInterval(() => {\r\n            // Reduce health by damage per second\r\n            this.health = Math.max(this.health-damagePerSecond, 0);\r\n    \r\n            // Check if the duration has elapsed\r\n            duration -= 1000; // Subtract 1 second (1000 milliseconds)\r\n            if (duration <= 0) {\r\n                // Clear the timer and stop the damage-over-time effect\r\n                clearInterval(dotTimer);\r\n                this.hasDot = false;\r\n            }\r\n        }, 1000); // Repeat every 1 second (1000 milliseconds)\r\n    }\r\n\r\n\r\n    applyShockwave() {\r\n\r\n   /*      this.camera.speed = this.camera.speed * 0.5; */\r\n   const originalWalkSpeed = this.walkSpeed;\r\n   const originalSprintSpeed = this.sprintSpeed;\r\n   this.walkSpeed *= 0.5;\r\n   this.sprintSpeed *= 0.5;\r\n   this.firstPersonController.applyShockwave();\r\n        setTimeout(() => {\r\n            this.walkSpeed = originalWalkSpeed;\r\n            this.sprintSpeed = originalSprintSpeed;\r\n            /* this.camera.speed = originalCameraSpeed; */\r\n        }, 6000);\r\n\r\n        this.health = Math.max(0, this.health - 20);\r\n        this.firstPersonController.playerBox.applyImpulse(new Vector3(0,4,0), this.firstPersonController.playerBox.getAbsolutePosition());\r\n    }\r\n\r\n    decayStamina() {\r\n\r\n        this.isRegenerating = false;\r\n        if(!this.isDecaying && !this.isRegenerating) {\r\n\r\n        clearInterval(this.regenInterval);\r\n            // Interval for stamina decay\r\n         this.decayInterval = setInterval(() => {\r\n            // Reduce stamina by decay rate\r\n            this.stamina = Math.max(0, this.stamina - this.staminaDecayRate);\r\n            if (this.stamina === 0) {\r\n                // Clear the interval if stamina reaches zero\r\n                this.outOfBreath.play();\r\n                clearInterval(this.decayInterval);\r\n            }\r\n        }, 1000); // Decay every second (1000 milliseconds)\r\n    \r\n        this.isDecaying = true;\r\n\r\n    }\r\n    }\r\n    \r\n\r\n    regenStamina() {\r\n\r\n        this.isDecaying = false;\r\n        if(!this.isRegenerating && !this.isDecaying) {\r\n        clearInterval(this.decayInterval);\r\n        // Interval for stamina regeneration\r\n         this.regenInterval = setInterval(() => {\r\n            // Increase stamina by regen rate, capped at maxStamina\r\n            this.stamina = Math.min(this.maxStamina, this.stamina + this.staminaRegenRate);\r\n            if (this.stamina === this.maxStamina) {\r\n                // Clear the interval if stamina reaches max\r\n                clearInterval(this.regenInterval);\r\n            }\r\n        }, 1000); // Regen every second (1000 milliseconds)\r\n    \r\n        this.isRegenerating = true;\r\n    }\r\n    }\r\n\r\n\r\n\r\n}","import { AdvancedDynamicTexture, Button, Control, Rectangle, TextBlock } from \"@babylonjs/gui\";\r\nimport { Player } from \"./Player\";\r\nimport { Weapon } from \"./Weapon\";\r\nimport { Level } from \"./Level\";\r\n\r\nexport class UI {\r\n\r\n\r\n    ammoTextBlock!: TextBlock;\r\n    healthBlock!: TextBlock;\r\n    staminaBlock!: TextBlock;\r\n    player: Player;\r\n    weapon: Weapon;\r\n    healthBar!: Rectangle;\r\n    staminaBar!: Rectangle;\r\n\r\n    inventory!: Weapon[];\r\n    currentWeaponIndex!: number;\r\n\r\n    coordinatesBlock!: TextBlock;\r\n    scoreBlock!: TextBlock;\r\n\r\n    level: Level;\r\n\r\n    waveBlock!: TextBlock;\r\n    waveTimeBlock!: TextBlock;\r\n\r\n    deathScreen!: Rectangle;\r\n    restartButton!:Button;\r\n\r\n    showDeathScreen: boolean;\r\n    showWinScreen: boolean;\r\n    winScreen: any;\r\n\r\n\r\n    pauseMenu!: Rectangle;\r\n    unpauseButton!: Button;\r\n\r\n    constructor(player: Player, weapon: Weapon, inventory: Weapon[], currentWeaponIndex: number, level: Level) {\r\n        this.player = player;\r\n        this.weapon = weapon;\r\n        \r\n        this.inventory = inventory;\r\n        this.currentWeaponIndex = currentWeaponIndex;\r\n       \r\n        this.showDeathScreen = false;\r\n        this.showWinScreen = false;\r\n\r\n        this.level = level;\r\n\r\n        this.loadText();\r\n        this.createPauseUI();\r\n    }\r\n\r\n    loadText(): void {\r\n        // Create a GUI texture\r\n        const advancedTexture = AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n    \r\n        // Create container for ammo text\r\n        const ammoContainer = new Rectangle();\r\n        ammoContainer.width = \"22%\";\r\n        ammoContainer.height = \"15%\";\r\n        ammoContainer.background = \"rgba(0, 0, 0, 0.45)\"; // Semi-transparent black background\r\n        ammoContainer.cornerRadius = 20; // Rounded corners\r\n        ammoContainer.thickness = 2; // Border thickness\r\n        ammoContainer.color = \"white\"; // Border color\r\n        ammoContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        ammoContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        ammoContainer.top = \"80%\";\r\n        ammoContainer.left = \"20%\";\r\n    \r\n     /*    // Add box shadow effect\r\n        ammoContainer.shadowBlur = 20; // Blur radius\r\n        ammoContainer.shadowOffsetX = 10; // Offset along X axis\r\n        ammoContainer.shadowOffsetY = 10; // Offset along Y axis\r\n        ammoContainer.shadowColor = \"#000000\"; // Shadow color\r\n     */\r\n        advancedTexture.addControl(ammoContainer);\r\n    \r\n        // Create a text block for ammo\r\n        this.ammoTextBlock = new TextBlock();\r\n        this.ammoTextBlock.color = \"rgb(0, 255, 0)\";\r\n        this.ammoTextBlock.fontFamily = \"Consolas\";\r\n        this.ammoTextBlock.fontWeight = \"bold\";\r\n        this.ammoTextBlock.fontSize = \"36vw\"; \r\n        ammoContainer.addControl(this.ammoTextBlock);\r\n    \r\n        this.updateAmmoText();\r\n    \r\n        // Create container for player health text\r\n        const healthContainer = new Rectangle();\r\n        healthContainer.width = \"15%\";\r\n        healthContainer.height = \"15%\";\r\n        healthContainer.background = \"rgba(0, 0, 0, 0.45)\";\r\n        healthContainer.cornerRadius = 20;\r\n        healthContainer.thickness = 2;\r\n        healthContainer.color = \"white\";\r\n        healthContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        healthContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        healthContainer.top = \"80%\";\r\n        healthContainer.left = \"3%\";\r\n    \r\n      /*   // Add box shadow effect\r\n        healthContainer.shadowBlur = 10; // Blur radius\r\n        healthContainer.shadowOffsetX = 5; // Offset along X axis\r\n        healthContainer.shadowOffsetY = 5; // Offset along Y axis\r\n        healthContainer.shadowColor = \"#000000\"; // Shadow color */\r\n    \r\n        advancedTexture.addControl(healthContainer);\r\n    \r\n        // Create a text block for player health\r\n        this.healthBlock = new TextBlock();\r\n        this.healthBlock.color = \"rgb(0, 255, 0)\";\r\n        this.healthBlock.fontFamily = \"Consolas\";\r\n        this.healthBlock.fontWeight = \"bold\";\r\n        this.healthBlock.fontSize = \"36vw\"; // Decreased font size for better fit\r\n      \r\n        healthContainer.addControl(this.healthBlock);\r\n\r\n\r\n\r\n     /* // Create a progress bar for player health\r\n     this.healthBar = new Rectangle();\r\n     this.healthBar.width = \"290px\";\r\n     this.healthBar.height = \"20px\";\r\n     this.healthBar.cornerRadius = 20;\r\n     this.healthBar.background = this.healthBlock.color; // Red color for the bar\r\n     this.healthBar.thickness = 1;\r\n     this.healthBar.color = \"darkgreen\";\r\n     this.healthBar.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n     this.healthBar.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n     this.healthBar.top = \"70px\";\r\n     this.healthBar.left = \"10px\";\r\n \r\n     // Add box shadow effect\r\n     this.healthBar.shadowBlur = 5; // Blur radius\r\n     this.healthBar.shadowOffsetX = 2; // Offset along X axis\r\n     this.healthBar.shadowOffsetY = 2; // Offset along Y axis\r\n     this.healthBar.shadowColor = \"#000000\"; // Shadow color\r\n \r\n     advancedTexture.addControl(this.healthBar); */\r\n \r\n        this.updatePlayerHP();\r\n\r\n\r\n\r\n\r\n        // Create a container for stamina text\r\n       /*  const staminaContainer = new Rectangle();\r\n        staminaContainer.width = \"200px\";\r\n        staminaContainer.height = \"100px\";\r\n        staminaContainer.background = \"rgba(0, 0, 0, 0.45)\"; // Semi-transparent black background\r\n        staminaContainer.cornerRadius = 20; // Rounded corners\r\n        staminaContainer.thickness = 2; // Border thickness\r\n        staminaContainer.color = \"white\"; // Border color\r\n        staminaContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        staminaContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        staminaContainer.top = \"1%\";\r\n        staminaContainer.left = \"40%\"; */\r\n    \r\n     /*    // Add box shadow effect\r\n        staminaContainer.shadowBlur = 10; // Blur radius\r\n        staminaContainer.shadowOffsetX = 5; // Offset along X axis\r\n        staminaContainer.shadowOffsetY = 5; // Offset along Y axis\r\n        staminaContainer.shadowColor = \"#000000\"; // Shadow color */\r\n    \r\n        //advancedTexture.addControl(staminaContainer);\r\n\r\n\r\n         // Create a stamina progress bar\r\n        this.staminaBar = new Rectangle();\r\n        this.staminaBar.width = \"350px\"; // Initially full width\r\n        this.staminaBar.height = \"15px\";\r\n        this.staminaBar.cornerRadius = 20;\r\n        this.staminaBar.thickness = 1;\r\n        this.staminaBar.background = \"cyan\"; // Cyan color\r\n        this.staminaBar.color = \"black\";\r\n        this.staminaBar.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this.staminaBar.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this.staminaBar.top = \"75%\";\r\n        this.staminaBar.left = \"5%\";\r\n\r\n                // Add box shadow effect\r\n        this.staminaBar.shadowBlur = 5; // Blur radius\r\n        this.staminaBar.shadowOffsetX = 2; // Offset along X axis\r\n        this.staminaBar.shadowOffsetY = 2; // Offset along Y axis\r\n        this.staminaBar.shadowColor = \"#000000\"; // Shadow color\r\n        \r\n        advancedTexture.addControl(this.staminaBar);\r\n     \r\n      /*   // Create a text block for stamina\r\n        this.staminaBlock = new TextBlock();\r\n        this.staminaBlock.color = \"cyan\";\r\n        this.staminaBlock.fontFamily = \"Consolas\";\r\n        this.staminaBlock.fontWeight = \"bold\";\r\n        this.staminaBlock.fontSize = 36; // Decreased font size for better fit\r\n        staminaContainer.addControl(this.staminaBlock); */\r\n    \r\n        this.updateStaminaText();\r\n\r\n\r\n\r\n\r\n                // Create a text block for player coordinates\r\n       /*  this.coordinatesBlock = new TextBlock();\r\n        this.coordinatesBlock.color = \"white\";\r\n        this.coordinatesBlock.fontFamily = \"Consolas\";\r\n        this.coordinatesBlock.fontWeight = \"bold\";\r\n        this.coordinatesBlock.fontSize = 18; \r\n        this.coordinatesBlock.text = \"(x, y, z): \"; // Initial text\r\n        this.coordinatesBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this.coordinatesBlock.textVerticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this.coordinatesBlock.top = \"20px\";\r\n        this.coordinatesBlock.left = \"650px\";\r\n\r\n        advancedTexture.addControl(this.coordinatesBlock); */\r\n\r\n        // Assuming you have access to the player's coordinates, update the text accordingly\r\n        //this.updatePlayerCoordinates();\r\n\r\n\r\n\r\n\r\n\r\n        \r\n        const scoreContainer = new Rectangle();\r\n        scoreContainer.width = \"520px\";\r\n        scoreContainer.height = \"90px\";\r\n        scoreContainer.background = \"rgba(0, 0, 0, 0.45)\"; \r\n        scoreContainer.cornerRadius = 20; \r\n        scoreContainer.thickness = 2; \r\n        scoreContainer.color = \"white\"; \r\n        scoreContainer.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        scoreContainer.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        scoreContainer.top = \"1%\";\r\n        scoreContainer.left = \"25%\";\r\n\r\n        advancedTexture.addControl(scoreContainer);\r\n\r\n\r\n\r\n\r\n              \r\n        this.scoreBlock = new TextBlock();\r\n        this.scoreBlock.color = \"rgb(0, 255, 0)\";\r\n        this.scoreBlock.fontFamily = \"Consolas\";\r\n        this.scoreBlock.fontWeight = \"bold\";\r\n        this.scoreBlock.fontSize = \"18vw\"; \r\n        this.scoreBlock.text = \"Score: \"; \r\n   this.scoreBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this.scoreBlock.textVerticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this.scoreBlock.top = \"53px\";\r\n        this.scoreBlock.left = \"200px\"; \r\n\r\n        scoreContainer.addControl(this.scoreBlock);\r\n\r\n\r\n        this.waveBlock = new TextBlock();\r\n        this.waveBlock.color = \"rgb(0, 255, 0)\";\r\n        this.waveBlock.fontFamily = \"Consolas\";\r\n        this.waveBlock.fontWeight = \"bold\";\r\n        this.waveBlock.fontSize = 18; \r\n        this.waveBlock.text = \"Wave: \"; \r\n        this.waveBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this.waveBlock.textVerticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this.waveBlock.top = \"5px\";\r\n        this.waveBlock.left = \"200px\";\r\n\r\n        scoreContainer.addControl(this.waveBlock);\r\n\r\n        \r\n\r\n        this.waveTimeBlock = new TextBlock();\r\n        this.waveTimeBlock.color = \"rgb(0, 255, 0)\";\r\n        this.waveTimeBlock.fontFamily = \"Consolas\";\r\n        this.waveTimeBlock.fontWeight = \"bold\";\r\n        this.waveTimeBlock.fontSize = 18; \r\n        this.waveTimeBlock.text = \"Prochaine vague: \"; \r\n        this.waveTimeBlock.textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_LEFT;\r\n        this.waveTimeBlock.textVerticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n        this.waveTimeBlock.top = \"30px\";\r\n       this.waveTimeBlock.left = \"120px\";\r\n\r\n        scoreContainer.addControl(this.waveTimeBlock);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // Pause menu\r\n        \r\n    }\r\n    \r\n    createPauseUI(): void {\r\n        const advancedTexture = AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n\r\n        this.pauseMenu = new Rectangle();\r\n        this.pauseMenu.width = 0.5;\r\n        this.pauseMenu.height = 0.5;\r\n        this.pauseMenu.background = \"black\";\r\n        this.pauseMenu.alpha = 0.8;\r\n        this.pauseMenu.isVisible = false;\r\n        advancedTexture.addControl(this.pauseMenu);\r\n\r\n        const pauseText = new TextBlock();\r\n        pauseText.text = \"Paused\";\r\n        pauseText.color = \"white\";\r\n        pauseText.fontSize = 40;\r\n        this.pauseMenu.addControl(pauseText);\r\n\r\n        this.unpauseButton = Button.CreateSimpleButton(\"unpauseButton\", \"Unpause\");\r\n        this.unpauseButton.width = \"150px\";\r\n        this.unpauseButton.height = \"50px\";\r\n        this.unpauseButton.color = \"white\";\r\n        this.unpauseButton.background = \"gray\";\r\n        this.unpauseButton.verticalAlignment = Control.VERTICAL_ALIGNMENT_BOTTOM;\r\n        this.unpauseButton.top = \"-10px\";\r\n        this.pauseMenu.addControl(this.unpauseButton);\r\n    }\r\n\r\n    showPauseScreen(): void {\r\n        if (this.pauseMenu) {\r\n            this.pauseMenu.isVisible = true;\r\n        }\r\n    }\r\n\r\n    hidePauseScreen(): void {\r\n        if (this.pauseMenu) {\r\n            this.pauseMenu.isVisible = false;\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    updateAmmoText(): void {\r\n       \r\n        this.ammoTextBlock.text = this.weapon.ammo.toString()+\" | \"+this.weapon.reloadAmmo.toString();\r\n        //this.ammoTextBlock.text = this.inventory[this.currentWeaponIndex].ammo.toString()+\" | \"+this.inventory[this.currentWeaponIndex].reloadAmmo.toString();\r\n    }\r\n\r\n \r\n    updateHealthBar(healthBar: Rectangle): void {\r\n        const healthPercentage = this.player.health / this.player.maxHealth;\r\n        healthBar.width = `${healthPercentage * 290}px`; \r\n        healthBar.background = this.healthBlock.color;\r\n    }\r\n\r\n    updatePlayerHP(): void {\r\n        const health = this.player.health;\r\n        this.healthBlock.text = health.toString();\r\n    \r\n       \r\n        let color = \"\";\r\n        if (health > 50) {\r\n            \r\n            const red = Math.floor(255 - (health - 50) * 5.1); \r\n            const green = 255;\r\n            color = `rgb(${red},${green},0)`;\r\n        } else {\r\n           \r\n            const green = Math.floor((health * 5.1));\r\n            const red = 255;\r\n            color = `rgb(${red},${green},0)`;\r\n        }\r\n    \r\n      \r\n        this.healthBlock.color = color;\r\n        //this.updateHealthBar(this.healthBar);\r\n    }\r\n\r\n\r\n    updateStaminaText(): void {\r\n       \r\n        //this.staminaBlock.text = this.player.stamina.toString();\r\n\r\n         const staminaPercentage = this.player.stamina / this.player.maxStamina;\r\n        this.staminaBar.width = `${staminaPercentage * 33}%`; \r\n    }\r\n    \r\n\r\n    // Function to update player coordinates text\r\n/* updatePlayerCoordinates() {\r\n\r\n\r\n\r\n    const playerX = 0;\r\n    const playerY =0;\r\n    const playerZ = 0;\r\n\r\n    \r\n\r\n    \r\n    this.coordinatesBlock.text = `(x: ${this.player.position.x.toFixed(2)}, y: ${this.player.position.y.toFixed(2)}, z: ${this.player.position.z.toFixed(2)})`;\r\n    \r\n} */\r\n\r\n\r\nupdatePlayerScore() {\r\n    this.scoreBlock.text = `Score: ${this.player.score}`;\r\n}\r\n\r\n\r\nupdateWaveNumber() {\r\n    this.waveBlock.text = `Vague: ${this.level.waveNumber}`;\r\n}\r\n\r\n\r\nupdateWaveTimer() {\r\n    this.waveTimeBlock.text = `Prochaine vague: ${this.level.nextWaveTime} secondes.`;\r\n}\r\n\r\n\r\n\r\ncreateDeathScreen(): void {\r\n    if(!this.showDeathScreen) {\r\n    const advancedTexture = AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n\r\n   \r\n    this.deathScreen = new Rectangle();\r\n    this.deathScreen.width = \"100%\";\r\n    this.deathScreen.height = \"100%\";\r\n    this.deathScreen.background = \"rgba(255, 0, 0, 0.5)\"; \r\n    this.deathScreen.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    this.deathScreen.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n    advancedTexture.addControl(this.deathScreen);\r\n\r\n\r\n\r\n\r\n    const youDiedText = new TextBlock();\r\n    youDiedText.text = \"Vous tes mort\";\r\n    youDiedText.color = \"white\";\r\n    youDiedText.fontSize = 32;\r\n    youDiedText.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    youDiedText.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n    youDiedText.top = \"-100px\"; // Adjust vertical position\r\n    this.deathScreen.addControl(youDiedText);\r\n\r\n  \r\n    const scoreText = new TextBlock();\r\n    scoreText.text = \"Score: \" + this.player.score;\r\n    scoreText.color = \"white\";\r\n    scoreText.fontSize = 24;\r\n    scoreText.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    scoreText.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n    scoreText.top = \"-50px\"; // Adjust vertical position\r\n    this.deathScreen.addControl(scoreText);\r\n\r\n\r\n\r\n\r\n    \r\n    this.restartButton = Button.CreateSimpleButton(\"restartButton\", \"Rejouer\");\r\n    this.restartButton.width = \"200px\";\r\n    this.restartButton.height = \"50px\";\r\n    this.restartButton.color = \"white\";\r\n    this.restartButton.background = \"black\";\r\n    this.restartButton.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    this.restartButton.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n\r\n   \r\n    this.restartButton.onPointerUpObservable.add(() => {\r\n       \r\n        advancedTexture.removeControl(this.deathScreen);\r\n\r\n\r\n        location.reload();\r\n    \r\n    });\r\n\r\n    this.deathScreen.addControl(this.restartButton);\r\n    this.showDeathScreen = true;\r\n\r\n    this.level.stopWaveSystem();\r\n}\r\n}\r\n\r\n\r\n\r\ncreateWinScreen() {\r\n    if(!this.showWinScreen) {\r\n        const advancedTexture = AdvancedDynamicTexture.CreateFullscreenUI(\"UI\");\r\n\r\n    \r\n    this.winScreen = new Rectangle();\r\n    this.winScreen.width = \"100%\";\r\n    this.winScreen.height = \"100%\";\r\n    this.winScreen.background = \"rgba(0, 255, 0, 0.5)\"; \r\n    this.winScreen.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    this.winScreen.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n    advancedTexture.addControl(this.winScreen);\r\n\r\n    const youWonText = new TextBlock();\r\n    youWonText.text = \"Vous avez gagn!\";\r\n    youWonText.color = \"white\";\r\n    youWonText.fontSize = 32;\r\n    youWonText.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    youWonText.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n    youWonText.top = \"-100px\"; \r\n    this.winScreen.addControl(youWonText);\r\n    \r\n    const scoreText = new TextBlock();\r\n    scoreText.text = \"Score: \" + this.player.score;\r\n    scoreText.color = \"white\";\r\n    scoreText.fontSize = 24;\r\n    scoreText.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    scoreText.verticalAlignment = Control.VERTICAL_ALIGNMENT_TOP;\r\n    scoreText.top = \"-50px\"; \r\n    this.winScreen.addControl(scoreText);\r\n\r\n\r\n\r\n\r\n   \r\n    this.restartButton = Button.CreateSimpleButton(\"restartButton\", \"Rejouer\");\r\n    this.restartButton.width = \"200px\";\r\n    this.restartButton.height = \"50px\";\r\n    this.restartButton.color = \"white\";\r\n    this.restartButton.background = \"black\";\r\n    this.restartButton.horizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    this.restartButton.verticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n\r\n  \r\n    this.restartButton.onPointerUpObservable.add(() => {\r\n       \r\n        advancedTexture.removeControl(this.winScreen);\r\n\r\n\r\n        location.reload();\r\n    \r\n    });\r\n\r\n    this.winScreen.addControl(this.restartButton);\r\n    this.showWinScreen = true;\r\n\r\n    this.level.stopWaveSystem();\r\n\r\n    }\r\n}\r\n\r\n\r\n}","import { AbstractMesh, Animation, AnimationGroup, Color3, FreeCamera, Material, Mesh, MeshBuilder, PBRMaterial, Ray, Scene, SceneLoader, Sound, StandardMaterial, Tags, Texture, TransformNode, Vector3, ParticleSystem, Color4 } from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\n\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Weapon } from \"./Weapon\";\r\nimport { Player } from \"./Player\";\r\n\r\nexport class M60 extends Weapon {\r\n\r\n    isFiring: boolean;\r\n    isReloading: boolean;\r\n    ammo: number;\r\n    reloadAmmo: number;\r\n\r\n\r\n    canFire!: boolean;\r\n    currentFireRate: number;\r\n\r\n    muzzleFlashParticleSystem: ParticleSystem | null = null;\r\n\r\n\r\n   \r\n\r\n    constructor(scene: Scene, camera: FreeCamera, enemies: Enemy[], player: Player, canvas: HTMLCanvasElement) {\r\n        super(scene, camera, enemies, player, canvas);\r\n\r\n        this.isFiring = false;\r\n        this.isReloading = false;\r\n        this.ammo = 50;\r\n        this.reloadAmmo = 600;\r\n     \r\n\r\n\r\n        this.fireRate = 100;\r\n        this.canFire = true;\r\n        this.currentFireRate = 0;\r\n        this.toggleAutomatic = true;\r\n\r\n        this.damage = 15;\r\n        \r\n        this.loadBulletholes();\r\n        \r\n    }\r\n\r\n\r\n    async CreateG(): Promise<void> {\r\n    \r\n\r\n        const {meshes, animationGroups} = await SceneLoader.ImportMeshAsync('', './models/', 'm60.glb');\r\n\r\n        this.gunMeshChild = meshes[1];\r\n    \r\n       \r\n        const transformNode = new TransformNode('glb');\r\n        \r\n      \r\n       \r\n            meshes[0].parent = transformNode;\r\n            meshes[0].isVisible = true;\r\n            meshes[0].renderingGroupId = 100;\r\n            this.gunMesh = meshes[0];\r\n\r\n\r\n            const start = 190;\r\n            const end = 250;\r\n           \r\n            this.animationGroups = animationGroups;\r\n            animationGroups.forEach( (animationGroup) => {\r\n                animationGroup.stop();\r\n            \r\n                \r\n                animationGroup.start(true, 0.5, 755, 850);\r\n                \r\n                \r\n               \r\n            });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        \r\n    \r\n        transformNode.parent = this.camera;\r\n        \r\n \r\n        transformNode.position.y -= 0.2;\r\n        transformNode.position.z += 0.5;\r\n        transformNode.position.x += 0.32;\r\n     \r\n     \r\n       \r\n        transformNode.scaling.set(1,1,1);\r\n     \r\n\r\n        this.CreateCrosshair();\r\n\r\n\r\n        \r\n        this.shootSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/lmgfire1.wav\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.shootSound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.emptySound = new Sound(\r\n            \"emptySound\",\r\n            \"./audio/empty.mp3\",\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.emptySound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.reloadSound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/LMGreload.wav\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.reloadSound.attachToMesh(this.gunMesh);\r\n        this.readySound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/weapons/readyLMG2.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.readySound.attachToMesh(this.gunMesh);\r\n\r\n        this.createMuzzleFlashParticleSystem();\r\n        this.isMeshCreated = true;\r\n    }\r\n\r\n\r\n\r\n    CreateCrosshair(): Mesh {\r\n        const size = 1;\r\n        const plane = MeshBuilder.CreatePlane('crosshair',{size});\r\n        // plane.position.x= -size/2;\r\n        // plane.position.y= -size/2;\r\n        const material = new StandardMaterial('crossHairMaterial',this.scene);\r\n        plane.material = material;\r\n        const texture = new Texture('./textures/crosshair.png', this.scene);\r\n        material.diffuseTexture=texture;\r\n        material.diffuseColor=Color3.White();\r\n        material.opacityTexture = material.diffuseTexture\r\n        material.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n        material.alpha = 1\r\n        texture.hasAlpha = true;\r\n        plane.parent = this.camera;\r\n        plane.position.z = 1;\r\n        plane.scaling = new Vector3(0.3/4,0.3/4,0.3/4);\r\n        plane.checkCollisions = false;\r\n        plane.isPickable = false;\r\n        return plane;\r\n    }\r\n\r\n\r\n\r\n    \r\n    shootAnimation(gun: Weapon) {\r\n\r\n       \r\n        \r\n\r\n        gun.animationGroups.forEach( (animationGroup) => {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1.5, 0, 21);\r\n    \r\n\r\n\r\n\r\n\r\n       \r\n        if (gun.muzzleFlashParticleSystem) {\r\n            gun.muzzleFlashParticleSystem.start();\r\n            setTimeout(() => {\r\n                gun.muzzleFlashParticleSystem!.stop();\r\n            }, 10);\r\n\r\n           /*  \r\n            this.scene.onBeforeRenderObservable.add(() => {\r\n               \r\n                this.muzzleFlashParticleSystem!.emitter = this.gunMesh;\r\n            }); */\r\n            \r\n        }\r\n\r\n\r\n\r\n            \r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n               \r\n                gun.isFiring = true;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n    \r\n    idleAnimation(gun: Weapon) {\r\n        if(!this.player.isDead()) {\r\n        if (gun.isFiring || !gun.isReloading) {\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n                animationGroup.stop();\r\n                animationGroup.start(true, 0.5, 755, 850);\r\n\r\n            });\r\n            gun.isFiring = false; // Reset the flag\r\n        }\r\n    }\r\n    }\r\n\r\n\r\n    reloadAnimation(gun: Weapon) {\r\n            gun.isReloading = true;\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 16, 320);\r\n    \r\n           \r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                \r\n                gun.isReloading = false;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n\r\n    readyAnimation(gun: Weapon): void {\r\n        gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 660, 754);\r\n    \r\n            \r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                \r\n               \r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n    shoot(): void {\r\n        if (this.canFire && !this.isReloading) {\r\n\r\n        if (this.ammo > 0) {\r\n\r\n                this.shootSound.play();\r\n\r\n                // Create the picking ray from the center of the screen with random deviation\r\n                const deviationAngle = Math.random() * Math.PI * 2; // Random angle between 0 and 2*pi\r\n                const deviationAmount = Math.random() * 0.04; // Random deviation amount\r\n                const deviationVector = new Vector3(Math.cos(deviationAngle) * deviationAmount, 0, Math.sin(deviationAngle) * deviationAmount);\r\n                \r\n                // Calculate the new ray direction with deviation\r\n                const rayDirection = this.camera.getForwardRay().direction.add(deviationVector);\r\n\r\n          \r\n\r\n\r\n\r\n\r\n\r\n\r\n            // Create the picking ray from the center of the screen\r\n            const ray = this.scene.createPickingRay(\r\n                this.canvas.clientWidth / 2,\r\n                this.canvas.clientHeight / 2,\r\n                null,\r\n                this.camera\r\n            );\r\n\r\n            ray.direction = rayDirection;\r\n    \r\n            \r\n            const raycastHit = this.scene.pickWithRay(ray);\r\n    \r\n           \r\n            if (raycastHit && raycastHit.hit) {\r\n                \r\n                if (Tags.MatchesQuery(raycastHit.pickedMesh!, \"enemy\")) {\r\n\r\n                  \r\n                    const enemy = this.getEnemyFromMesh(raycastHit.pickedMesh!);\r\n                    if(enemy) {\r\n                    \r\n                    enemy!.health -= this.damage;\r\n\r\n                    //console.log(\"dead?\" , enemy!.states.DESTROYED);\r\n\r\n                    if (enemy!.health > 0) {\r\n                        // Play shot animation on the enemy\r\n                        this.playShotAnimation(enemy!);\r\n                       \r\n                    }\r\n    \r\n                    // Check if the enemy's HP has reached 0\r\n                    if (enemy!.health <= 0) {\r\n                        if(!enemy!.states.DESTROYED) {\r\n                            this.player.score += enemy!.scoreValue;\r\n                       \r\n                        this.playDeathAnimation(enemy!);\r\n                        enemy!.death.onAnimationEndObservable.addOnce(()=>{\r\n                            if(enemy) {\r\n                            const index = this.enemies.indexOf(enemy!);\r\n                            if (index !== -1) {\r\n                               \r\n                                this.enemies.splice(index, 1);\r\n                            }\r\n\r\n                            const indexFPS = this.player.firstPersonController.enemies.indexOf(enemy);\r\n                            if (indexFPS !== -1) {\r\n                               \r\n                                this.player.firstPersonController.enemies.splice(indexFPS, 1);\r\n                            }\r\n\r\n\r\n\r\n                          \r\n                        }\r\n\r\n\r\n                        });\r\n\r\n                        \r\n                        enemy!.states.DESTROYED = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n    \r\n                // Create a decal to indicate the impact of the shot\r\n                const size = 0.1;\r\n                const decal = MeshBuilder.CreateDecal(\"decal\", raycastHit.pickedMesh!, {\r\n                    position: raycastHit.pickedPoint!,\r\n                    normal: raycastHit.getNormal(true)!,\r\n                    size: new Vector3(size, size, size)\r\n                });\r\n                decal.material = this.bulletHoleMaterial;\r\n                //console.log(\"Raycast hit something\");\r\n\r\n                // Dispose of the decal after 10 seconds\r\n                    setTimeout(() => {\r\n                        decal.dispose();\r\n                    }, 10000);\r\n                }\r\n                        \r\n            // Reduce ammo count and update UI\r\n            this.ammo -= 1;\r\n            // this.updateAmmoText(); \r\n        }\r\n        }\r\n    }\r\n\r\n\r\n    reloadWeapon() {\r\n        const remainingAmmo = this.ammo;\r\n        const reloadAmount = Math.min(50 - remainingAmmo, this.reloadAmmo);\r\n        this.ammo += reloadAmount;\r\n        this.reloadAmmo -= reloadAmount;\r\n        //this.updateAmmoText();\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    getEnemyFromMesh(mesh: AbstractMesh): Enemy | undefined {\r\n        \r\n        for (const enemy of this.enemies) {\r\n            if (enemy.mesh === mesh) {\r\n                return enemy;\r\n            }\r\n        }\r\n\r\n        return undefined; \r\n    }\r\n    \r\n\r\n    async loadBulletholes() {\r\n        this.bulletHoleMaterial = new PBRMaterial(\"bulletHoleMaterial\", this.scene);\r\n\r\n        \r\n\r\n       this.bulletHoleMaterial.albedoTexture = new Texture(\"textures/bullet_hole.png\", this.scene);\r\n\r\n        \r\n        this.bulletHoleMaterial.albedoTexture.hasAlpha = true;\r\n        this.bulletHoleMaterial.zOffset = -0.25;\r\n        this.bulletHoleMaterial.roughness = 0.5;\r\n \r\n      \r\n    \r\n}\r\n\r\ncreateMuzzleFlashParticleSystem(): void {\r\n    \r\n    this.muzzleFlashParticleSystem = new ParticleSystem(\"muzzleFlash\", 200, this.scene);\r\n    \r\n    \r\n    const texture = new Texture(\"./textures/particles/muzzle_05.png\", this.scene);\r\n    texture._parentContainer = this.gunMesh;\r\n    this.muzzleFlashParticleSystem.particleTexture = texture;\r\n    \r\n    \r\n    this.muzzleFlashParticleSystem.emitter = this.gunMesh; // Set emitter to gun mesh\r\n    this.muzzleFlashParticleSystem.minEmitBox = new Vector3(-0.2, 0.1, 4); \r\n    this.muzzleFlashParticleSystem.maxEmitBox = new Vector3(-0.2, 0.1, 4); \r\n      \r\n\r\n    this.muzzleFlashParticleSystem.color1 = new Color4(0.8, 0.5, 0, 1); // Bright yellow-orange \r\n    this.muzzleFlashParticleSystem.color2 = new Color4(0.8, 0.5, 0, 1); \r\n    this.muzzleFlashParticleSystem.colorDead = new Color4(1, 0.5, 0, 1); \r\n    \r\n       \r\n    this.muzzleFlashParticleSystem.minSize = 1; \r\n    this.muzzleFlashParticleSystem.maxSize = 1.5; \r\n    this.muzzleFlashParticleSystem.minLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.maxLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.emitRate = 20; \r\n\r\n   \r\n    \r\n\r\n    \r\n    \r\n\r\n    this.muzzleFlashParticleSystem.start();\r\n    this.muzzleFlashParticleSystem.stop(); \r\n\r\n\r\n    \r\n}\r\n\r\n\r\n\r\n\r\ncontrolFireRate() {\r\n    if (!this.canFire) {\r\n        this.currentFireRate -= this.scene.getEngine().getDeltaTime();\r\n        \r\n        if (this.currentFireRate <= 0) {\r\n            this.canFire = true;\r\n            this.currentFireRate = this.fireRate;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","import { AbstractMesh, Animation, AnimationGroup, Color3, FreeCamera, Material, Mesh, MeshBuilder, PBRMaterial, Ray, Scene, SceneLoader, Sound, StandardMaterial, Tags, Texture, TransformNode, Vector3, ParticleSystem, Color4 } from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\n\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Weapon } from \"./Weapon\";\r\nimport { Player } from \"./Player\";\r\n\r\nexport class Pistol extends Weapon {\r\n\r\n    isFiring: boolean;\r\n    isReloading: boolean;\r\n    ammo: number;\r\n    reloadAmmo: number;\r\n\r\n\r\n    canFire!: boolean;\r\n    currentFireRate: number;\r\n\r\n    muzzleFlashParticleSystem: ParticleSystem | null = null;\r\n\r\n\r\n    damage: number;\r\n    \r\n\r\n\r\n    constructor(scene: Scene, camera: FreeCamera, enemies: Enemy[], player: Player, canvas: HTMLCanvasElement) {\r\n        super(scene, camera, enemies, player, canvas);\r\n        this.scene.getEngine().displayLoadingUI();\r\n\r\n        this.isFiring = false;\r\n        this.isReloading = false;\r\n        this.ammo = 12;\r\n        this.reloadAmmo = 36;\r\n     \r\n\r\n\r\n        this.fireRate = 100;\r\n        this.canFire = true;\r\n        this.currentFireRate = 0;\r\n        this.toggleAutomatic = false;\r\n\r\n\r\n        this.damage = 10;\r\n        \r\n        this.loadBulletholes();\r\n        \r\n    }\r\n\r\n\r\n    async CreateG(): Promise<void> {\r\n        //const mesh = await SceneLoader.ImportMeshAsync('', './models/', 'rifle.glb');\r\n\r\n        const {meshes, animationGroups} = await SceneLoader.ImportMeshAsync('', './models/', 'pistol.glb');\r\n\r\n        this.gunMeshChild = meshes[1];\r\n  /*       this.player.firstPersonController.level.shadowGen.addShadowCaster(this.gunMeshChild);\r\n        this.gunMeshChild.receiveShadows = true; */\r\n    \r\n        // Create a new TransformNode to hold the gun meshes\r\n        const transformNode = new TransformNode('glb');\r\n        \r\n        // Parent each mesh in the loaded model to the TransformNode\r\n       \r\n            meshes[0].parent = transformNode;\r\n            meshes[0].isVisible = true;\r\n            meshes[0].renderingGroupId = 100;\r\n            this.gunMesh = meshes[0];\r\n\r\n\r\n            const start = 190;\r\n            const end = 250;\r\n           \r\n            this.animationGroups = animationGroups;\r\n            animationGroups.forEach( (animationGroup) => {\r\n                animationGroup.stop();\r\n                //animationGroup.start(true, 0.1, 0, 10); // shoot\r\n                \r\n                animationGroup.start(true, 0.2, 436, 498);\r\n                \r\n\r\n               \r\n            });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        \r\n        // Parent the TransformNode to the camera\r\n        transformNode.parent = this.camera;\r\n        \r\n        // Adjust the position of the gun relative to the camera\r\n        transformNode.position.y -= 0.16;\r\n        transformNode.position.z += 0.5;\r\n        transformNode.position.x += 0.32;\r\n        \r\n        // Adjust the rotation of the gun\r\n     \r\n        // Adjust the scaling of the gun\r\n        transformNode.scaling.set(0.01,0.01,0.01);\r\n        // transformNode.scaling.set(0.5, 0.5, 0.5  ); // gun\r\n\r\n\r\n        this.CreateCrosshair();\r\n\r\n\r\n        \r\n        this.shootSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/pistolshoot.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.shootSound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.emptySound = new Sound(\r\n            \"emptySound\",\r\n            \"./audio/empty.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.emptySound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.reloadSound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/reload.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.reloadSound.attachToMesh(this.gunMesh);\r\n\r\n        this.readySound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/weapons/readyRifle.mp3\", // Chemin vers le fichier audio\r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.readySound.attachToMesh(this.gunMesh);\r\n\r\n\r\n        this.createMuzzleFlashParticleSystem();\r\n        this.isMeshCreated = true;\r\n\r\n        //this.scene.getEngine().hideLoadingUI();\r\n    }\r\n\r\n\r\n\r\n    CreateCrosshair(): Mesh {\r\n        const size = 1;\r\n        const plane = MeshBuilder.CreatePlane('crosshair',{size});\r\n        // plane.position.x= -size/2;\r\n        // plane.position.y= -size/2;\r\n        const material = new StandardMaterial('crossHairMaterial',this.scene);\r\n        plane.material = material;\r\n        const texture = new Texture('./textures/crosshair.png', this.scene);\r\n        material.diffuseTexture=texture;\r\n        material.diffuseColor=Color3.White();\r\n        material.opacityTexture = material.diffuseTexture\r\n        material.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n        material.alpha = 1\r\n        texture.hasAlpha = true;\r\n        plane.parent = this.camera;\r\n        plane.position.z = 1;\r\n        plane.scaling = new Vector3(0.3/4,0.3/4,0.3/4);\r\n        plane.checkCollisions = false;\r\n        plane.isPickable = false;\r\n        return plane;\r\n    }\r\n\r\n\r\n\r\n    \r\n    shootAnimation(gun: Weapon) {\r\n\r\n       \r\n        \r\n\r\n        gun.isFiring = true;\r\n        gun.animationGroups.forEach( (animationGroup) => {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 0, 28);\r\n    \r\n        \r\n\r\n\r\n\r\n\r\n        // Start the muzzle flash particle system when the shooting animation begins\r\n        if (gun.muzzleFlashParticleSystem) {\r\n            gun.muzzleFlashParticleSystem.start();\r\n            setTimeout(() => {\r\n                gun.muzzleFlashParticleSystem!.stop();\r\n            }, 10); // Adjust duration of the muzzle flash\r\n\r\n           /*  // Update the position of the particle system on each frame\r\n            this.scene.onBeforeRenderObservable.add(() => {\r\n                // Update the position of the particle system to match the position of the gun mesh\r\n                this.muzzleFlashParticleSystem!.emitter = this.gunMesh;\r\n            }); */\r\n            \r\n        }\r\n\r\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n            // Register a callback for when the animation ends\r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                // Start the idle animation when the shoot animation ends\r\n                //gun.isFiring = true;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n    \r\n    idleAnimation(gun: Weapon) {\r\n        if(!this.player.isDead()) {\r\n        if (gun.isFiring || !gun.isReloading) {\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n                animationGroup.stop();\r\n                animationGroup.start(true, 0.2, 436, 498);\r\n\r\n            });\r\n            gun.isFiring = false; // Reset the flag\r\n        }\r\n    }\r\n    }\r\n\r\n\r\n    reloadAnimation(gun: Weapon) {\r\n            gun.isReloading = true;\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 135, 315);\r\n    \r\n            // Register a callback for when the animation ends\r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                // Start the idle animation when the shoot animation ends\r\n                gun.isReloading = false;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n\r\n    readyAnimation(gun: Weapon) {\r\n        gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            //animationGroup.start(false, 1.5, 230, 315);\r\n            animationGroup.start(false, 1, 340, 435);\r\n            // Register a callback for when the animation ends\r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                // Start the idle animation when the shoot animation ends\r\n                //gun.isReloading = true;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    shoot(): void {\r\n        if (this.canFire && !this.isReloading) {\r\n\r\n        if (this.ammo > 0) {\r\n\r\n                this.shootSound.play();\r\n\r\n                        // Create the picking ray from the center of the screen with random deviation\r\n                const deviationAngle = Math.random() * Math.PI * 2; // Random angle between 0 and 2*pi\r\n                const deviationAmount = Math.random() * 0.04; // Random deviation amount\r\n                const deviationVector = new Vector3(Math.cos(deviationAngle) * deviationAmount, 0, Math.sin(deviationAngle) * deviationAmount);\r\n                \r\n                // Calculate the new ray direction with deviation\r\n                const rayDirection = this.camera.getForwardRay().direction.add(deviationVector);\r\n\r\n          \r\n\r\n\r\n    \r\n\r\n\r\n\r\n\r\n            // Create the picking ray from the center of the screen\r\n            const ray = this.scene.createPickingRay(\r\n                this.canvas.clientWidth / 2,\r\n                this.canvas.clientHeight / 2,\r\n                null,\r\n                this.camera\r\n            );\r\n\r\n            //ray.direction = rayDirection;\r\n    \r\n            // Perform the raycast and check for hits\r\n            const raycastHit = this.scene.pickWithRay(ray);\r\n    \r\n            // Check if the ray hit something\r\n            if (raycastHit && raycastHit.hit) {\r\n                // Check if the hit object has the \"enemy\" tag\r\n                if (Tags.MatchesQuery(raycastHit.pickedMesh!, \"enemy\")) {\r\n\r\n                    // Get the enemy instance associated with the hit object\r\n                    const enemy = this.getEnemyFromMesh(raycastHit.pickedMesh!);\r\n    \r\n                    if(enemy) {\r\n                    // Reduce the enemy's HP by 10\r\n                    enemy!.health -= this.damage;\r\n\r\n                    //console.log(\"dead?\" , enemy!.states.DESTROYED);\r\n\r\n                    if (enemy!.health > 0) {\r\n                        // Play shot animation on the enemy\r\n                        this.playShotAnimation(enemy!);\r\n                       \r\n                    }\r\n    \r\n                    // Check if the enemy's HP has reached 0\r\n                    if (enemy!.health <= 0) {\r\n                        if(!enemy!.states.DESTROYED) {\r\n                            this.player.score += enemy!.scoreValue;\r\n                        // Play death animation if the enemy is killed\r\n                        this.playDeathAnimation(enemy!);\r\n                        enemy!.death.onAnimationEndObservable.addOnce(()=>{\r\n                           if(enemy) {\r\n                            const index = this.enemies.indexOf(enemy);\r\n                            if (index !== -1) {\r\n                               \r\n                                this.enemies.splice(index, 1);\r\n                            }\r\n\r\n                            const indexFPS = this.player.firstPersonController.enemies.indexOf(enemy);\r\n                            if (indexFPS !== -1) {\r\n                                \r\n                                this.player.firstPersonController.enemies.splice(indexFPS, 1);\r\n                            }\r\n                           \r\n                        }\r\n\r\n                        \r\n                          \r\n                  \r\n       \r\n                        });\r\n\r\n\r\n                        \r\n                       \r\n                        enemy!.states.DESTROYED = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n    \r\n                // Create a decal to indicate the impact of the shot\r\n                const size = 0.1;\r\n                const decal = MeshBuilder.CreateDecal(\"decal\", raycastHit.pickedMesh!, {\r\n                    position: raycastHit.pickedPoint!,\r\n                    normal: raycastHit.getNormal(true)!,\r\n                    size: new Vector3(size, size, size)\r\n                });\r\n                decal.material = this.bulletHoleMaterial;\r\n                //console.log(\"Raycast hit something\");\r\n\r\n                   // Dispose of the decal after 10 seconds\r\n                   setTimeout(() => {\r\n                    decal.dispose();\r\n                }, 10000);\r\n            }\r\n    \r\n            // Reduce ammo count and update UI\r\n            this.ammo -= 1;\r\n            // this.updateAmmoText(); \r\n        }\r\n        }\r\n    }\r\n    \r\n\r\n\r\n    reloadWeapon() {\r\n        const remainingAmmo = this.ammo;\r\n        const reloadAmount = Math.min(12 - remainingAmmo, this.reloadAmmo);\r\n        this.ammo += reloadAmount;\r\n        this.reloadAmmo -= reloadAmount;\r\n        //this.updateAmmoText();\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    getEnemyFromMesh(mesh: AbstractMesh): Enemy | undefined {\r\n        \r\n        for (const enemy of this.enemies) {\r\n            if (enemy.mesh === mesh) {\r\n                return enemy;\r\n            }\r\n        }\r\n\r\n        return undefined; \r\n    }\r\n    \r\n\r\n    async loadBulletholes() {\r\n        this.bulletHoleMaterial = new PBRMaterial(\"bulletHoleMaterial\", this.scene);\r\n\r\n        \r\n        // Load the bullet hole texture\r\n       this.bulletHoleMaterial.albedoTexture = new Texture(\"textures/bullet_hole.png\", this.scene);\r\n\r\n        // Create a material with the bullet hole texture\r\n        \r\n        this.bulletHoleMaterial.albedoTexture.hasAlpha = true;\r\n        this.bulletHoleMaterial.zOffset = -0.25;\r\n        this.bulletHoleMaterial.roughness = 0.5;\r\n        //this.bulletHoleMaterial.zOffset = -0.25;\r\n        /* this.splatter = new PBRMaterial(\"greenSplatter\", this.scene);\r\n        this.splatter.roughness = 1;\r\n        this.splatter.albedoTexture = new Texture(\"textures/green.png\", this.scene);\r\n        this.splatter.albedoTexture.hasAlpha = true;\r\n*/\r\n      \r\n    \r\n}\r\n\r\n\r\ncreateMuzzleFlashParticleSystem(): void {\r\n    // Create particle system\r\n    this.muzzleFlashParticleSystem = new ParticleSystem(\"muzzleFlash\", 200, this.scene);\r\n    \r\n    // Set particle texture\r\n    const texture = new Texture(\"./textures/particles/muzzle_05.png\", this.scene);\r\n    texture._parentContainer = this.gunMesh;\r\n    this.muzzleFlashParticleSystem.particleTexture = texture;\r\n    \r\n    // Set particle system properties\r\n    this.muzzleFlashParticleSystem.emitter = this.gunMesh; // Set emitter to gun mesh\r\n    this.muzzleFlashParticleSystem.minEmitBox = new Vector3(-8, 7, 100); \r\n    this.muzzleFlashParticleSystem.maxEmitBox = new Vector3(-8, 7, 100); \r\n  \r\n\r\n    this.muzzleFlashParticleSystem.color1 = new Color4(0.8, 0.5, 0, 1); // Bright yellow-orange\r\n    this.muzzleFlashParticleSystem.color2 = new Color4(0.8, 0.5, 0, 1); \r\n    this.muzzleFlashParticleSystem.colorDead = new Color4(1, 0.5, 0, 1); \r\n    \r\n       \r\n    this.muzzleFlashParticleSystem.minSize = 0.3; \r\n    this.muzzleFlashParticleSystem.maxSize = 0.74; \r\n    this.muzzleFlashParticleSystem.minLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.maxLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.emitRate = 10; \r\n\r\n   \r\n    \r\n\r\n    \r\n    \r\n    \r\n    this.muzzleFlashParticleSystem.start();\r\n    this.muzzleFlashParticleSystem.stop(); \r\n\r\n\r\n    \r\n}\r\n\r\n\r\n\r\ncontrolFireRate() {\r\n    if (!this.canFire) {\r\n        this.currentFireRate -= this.scene.getEngine().getDeltaTime();\r\n        \r\n        if (this.currentFireRate <= 0) {\r\n            this.canFire = true;\r\n            this.currentFireRate = this.fireRate;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","import { AbstractMesh, Animation, AnimationGroup, Color3, FreeCamera, Material, Mesh, MeshBuilder, PBRMaterial, Ray, Scene, SceneLoader, Sound, StandardMaterial, Tags, Texture, TransformNode, Vector3, ParticleSystem, Color4, Quaternion } from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\n\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Weapon } from \"./Weapon\";\r\nimport { Player } from \"./Player\";\r\n\r\nexport class Minigun extends Weapon {\r\n\r\n    isFiring: boolean;\r\n    isReloading: boolean;\r\n    ammo: number;\r\n    reloadAmmo: number;\r\n\r\n\r\n    canFire!: boolean;\r\n    currentFireRate: number;\r\n\r\n    muzzleFlashParticleSystem: ParticleSystem | null = null;\r\n\r\n\r\n\r\n    isReadying: boolean;\r\n\r\n\r\n    constructor(scene: Scene, camera: FreeCamera, enemies: Enemy[], player: Player, canvas: HTMLCanvasElement) {\r\n        super(scene, camera, enemies, player, canvas);\r\n\r\n        this.isFiring = false;\r\n        this.isShootingAnimationPlaying = false;\r\n        this.isReloading = false;\r\n        this.isReadying = false;\r\n        this.ammo = 100;\r\n        this.reloadAmmo = 600;\r\n     \r\n\r\n\r\n        this.fireRate = 55;\r\n        this.canFire = true;\r\n        this.currentFireRate = 0;\r\n        this.toggleAutomatic = true;\r\n\r\n        this.damage = 17;\r\n       \r\n\r\n        this.loadBulletholes();\r\n        \r\n    }\r\n\r\n\r\n    async CreateG(): Promise<void> {\r\n      \r\n\r\n        const {meshes, animationGroups} = await SceneLoader.ImportMeshAsync('', './models/', 'minigun.glb');\r\n\r\n        this.gunMeshChild = meshes[1];\r\n    \r\n       \r\n        const transformNode = new TransformNode('glb');\r\n        \r\n        \r\n       \r\n            meshes[0].parent = transformNode;\r\n            meshes[0].isVisible = true;\r\n            meshes[0].renderingGroupId = 100;\r\n            this.gunMesh = meshes[0];\r\n\r\n\r\n            const start = 190;\r\n            const end = 250;\r\n           \r\n            this.animationGroups = animationGroups;\r\n            animationGroups.forEach( (animationGroup) => {\r\n                animationGroup.stop();\r\n               \r\n                \r\n                animationGroup.start(true, 0.5, 14, 120);\r\n               \r\n\r\n               \r\n            });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        \r\n        \r\n        transformNode.parent = this.camera;\r\n        \r\n        \r\n        transformNode.position.y -= 0.2;\r\n        transformNode.position.z += 0.5;\r\n        transformNode.position.x += 0.32;\r\n        \r\n        transformNode.rotate(Vector3.Up(), Math.PI/16);\r\n      \r\n     \r\n       \r\n        transformNode.scaling.set(1,1,1);\r\n       \r\n\r\n\r\n        this.CreateCrosshair();\r\n\r\n\r\n        \r\n        this.shootSound = new Sound(\r\n            \"shootSound\",\r\n            \"./audio/lmgfire1.wav\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 0.5,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.shootSound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.emptySound = new Sound(\r\n            \"emptySound\",\r\n            \"./audio/empty.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.emptySound.attachToMesh(this.gunMesh);\r\n\r\n\r\n\r\n        this.reloadSound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/minigunreload.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 1,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.reloadSound.attachToMesh(this.gunMesh);\r\n        this.readySound = new Sound(\r\n            \"reloadSound\",\r\n            \"./audio/weapons/readyRifle.mp3\", \r\n            this.scene,\r\n            null,\r\n            {\r\n                spatialSound: true,\r\n                volume: 0,\r\n                autoplay: false\r\n            }\r\n        );\r\n        this.readySound.attachToMesh(this.gunMesh);\r\n\r\n        this.createMuzzleFlashParticleSystem();\r\n        this.isMeshCreated = true;\r\n    }\r\n\r\n\r\n\r\n    CreateCrosshair(): Mesh {\r\n        const size = 1;\r\n        const plane = MeshBuilder.CreatePlane('crosshair',{size});\r\n        \r\n        const material = new StandardMaterial('crossHairMaterial',this.scene);\r\n        plane.material = material;\r\n        const texture = new Texture('./textures/crosshair.png', this.scene);\r\n        material.diffuseTexture=texture;\r\n        material.diffuseColor=Color3.White();\r\n        material.opacityTexture = material.diffuseTexture\r\n        material.transparencyMode = Material.MATERIAL_ALPHABLEND;\r\n        material.alpha = 1\r\n        texture.hasAlpha = true;\r\n        plane.parent = this.camera;\r\n        plane.position.z = 1;\r\n        plane.scaling = new Vector3(0.3/4,0.3/4,0.3/4);\r\n        plane.checkCollisions = false;\r\n        plane.isPickable = false;\r\n        return plane;\r\n    }\r\n\r\n\r\n\r\n    \r\n    shootAnimation(gun: Weapon) {\r\n        if (!gun.isShootingAnimationPlaying) {\r\n            gun.isFiring = true;\r\n            gun.isShootingAnimationPlaying = true;\r\n    \r\n            gun.animationGroups.forEach((animationGroup) => {\r\n                animationGroup.stop();\r\n                animationGroup.start(false, 0.6, 4, 12);\r\n    \r\n             \r\n                animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                  \r\n                    gun.idleAnimation(gun);\r\n                    gun.isShootingAnimationPlaying = false; \r\n                });\r\n            });\r\n        }\r\n    }\r\n\r\n    muzzleAnimation(gun: Weapon) {\r\n         \r\n          if (gun.muzzleFlashParticleSystem) {\r\n            gun.muzzleFlashParticleSystem.start();\r\n            setTimeout(() => {\r\n                gun.muzzleFlashParticleSystem!.stop();\r\n            }, 10); \r\n            \r\n        }\r\n    }\r\n\r\n    idleAnimation(gun: Weapon) {\r\n        if(!this.player.isDead()) {\r\n        if (gun.isFiring || !gun.isReloading) {\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n                animationGroup.stop();\r\n                animationGroup.start(true, 0.5, 14, 120);\r\n                \r\n            });\r\n            gun.isFiring = false; \r\n            gun.isShootingAnimationPlaying = false;\r\n        }\r\n    }\r\n    }\r\n\r\n\r\n    reloadAnimation(gun: Weapon) {\r\n\r\n            gun.isReloading = true;\r\n            gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 121, 258);\r\n    \r\n           \r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n           \r\n                gun.isReloading = false;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n    }\r\n\r\n\r\n\r\n    readyAnimation(gun: Weapon): void {\r\n\r\n        gun.isReadying = true;\r\n        gun.animationGroups.forEach(function (animationGroup) {\r\n            animationGroup.stop();\r\n            animationGroup.start(false, 1, 280, 320);\r\n    \r\n\r\n            animationGroup.onAnimationEndObservable.addOnce(() => {\r\n                \r\n                gun.isReadying = false;\r\n                gun.idleAnimation(gun);\r\n            });\r\n        });\r\n       \r\n       \r\n    }\r\n\r\n    shoot(): void {\r\n        if (this.canFire && !this.isReloading) {\r\n\r\n        if (this.ammo > 0) {\r\n\r\n                this.shootSound.play();\r\n\r\n                       \r\n                const deviationAngle = Math.random() * Math.PI * 2;\r\n                const deviationAmount = Math.random() * 0.04; \r\n                const deviationVector = new Vector3(Math.cos(deviationAngle) * deviationAmount, 0, Math.sin(deviationAngle) * deviationAmount);\r\n                \r\n              \r\n                const rayDirection = this.camera.getForwardRay().direction.add(deviationVector);\r\n\r\n          \r\n\r\n\r\n\r\n\r\n\r\n\r\n          \r\n            const ray = this.scene.createPickingRay(\r\n                this.canvas.clientWidth / 2,\r\n                this.canvas.clientHeight / 2,\r\n                null,\r\n                this.camera\r\n            );\r\n\r\n            ray.direction = rayDirection;\r\n    \r\n          \r\n            const raycastHit = this.scene.pickWithRay(ray);\r\n    \r\n         \r\n            if (raycastHit && raycastHit.hit) {\r\n              \r\n                if (Tags.MatchesQuery(raycastHit.pickedMesh!, \"enemy\")) {\r\n\r\n                  \r\n                    const enemy = this.getEnemyFromMesh(raycastHit.pickedMesh!);\r\n                    if(enemy) {\r\n                  \r\n                    enemy!.health -= this.damage;\r\n\r\n                    \r\n\r\n                    if (enemy!.health > 0) {\r\n                      \r\n                        this.playShotAnimation(enemy!);\r\n                       \r\n                    }\r\n    \r\n                    // Check if the enemy's HP has reached 0\r\n                    if (enemy!.health <= 0) {\r\n                        if(!enemy!.states.DESTROYED) {\r\n                            this.player.score += enemy!.scoreValue;\r\n                        // Play death animation if the enemy is killed\r\n                        this.playDeathAnimation(enemy!);\r\n                        enemy!.death.onAnimationEndObservable.addOnce(()=>{\r\n                            if(enemy) {\r\n                            const index = this.enemies.indexOf(enemy!);\r\n                            if (index !== -1) {\r\n                             \r\n                                this.enemies.splice(index, 1);\r\n                            }\r\n\r\n\r\n                            const indexFPS = this.player.firstPersonController.enemies.indexOf(enemy);\r\n                            if (indexFPS !== -1) {\r\n                               \r\n                                this.player.firstPersonController.enemies.splice(indexFPS, 1);\r\n                            }\r\n\r\n\r\n\r\n                            \r\n                        }\r\n\r\n\r\n                        });\r\n\r\n                        enemy!.states.DESTROYED = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n    \r\n                // Create a decal to indicate the impact of the shot\r\n                const size = 0.1;\r\n                const decal = MeshBuilder.CreateDecal(\"decal\", raycastHit.pickedMesh!, {\r\n                    position: raycastHit.pickedPoint!,\r\n                    normal: raycastHit.getNormal(true)!,\r\n                    size: new Vector3(size, size, size)\r\n                });\r\n                decal.material = this.bulletHoleMaterial;\r\n                //console.log(\"Raycast hit something\");\r\n\r\n                // Dispose of the decal after 10 seconds\r\n                    setTimeout(() => {\r\n                        decal.dispose();\r\n                    }, 10000);\r\n                }\r\n                        \r\n            // Reduce ammo count and update UI\r\n            this.ammo -= 1;\r\n            // this.updateAmmoText(); \r\n        }\r\n        }\r\n    }\r\n    \r\n\r\n\r\n    reloadWeapon() {\r\n        const remainingAmmo = this.ammo;\r\n        const reloadAmount = Math.min(100 - remainingAmmo, this.reloadAmmo);\r\n        this.ammo += reloadAmount;\r\n        this.reloadAmmo -= reloadAmount;\r\n        //this.updateAmmoText();\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    \r\n\r\n\r\n    getEnemyFromMesh(mesh: AbstractMesh): Enemy | undefined {\r\n        \r\n        for (const enemy of this.enemies) {\r\n            if (enemy.mesh === mesh) {\r\n                return enemy;\r\n            }\r\n        }\r\n\r\n        return undefined; \r\n        //throw new Error(\"Enemy not found for the given mesh.\");\r\n    }\r\n    \r\n\r\n    async loadBulletholes() {\r\n        this.bulletHoleMaterial = new PBRMaterial(\"bulletHoleMaterial\", this.scene);\r\n\r\n        \r\n        // Load the bullet hole texture\r\n       this.bulletHoleMaterial.albedoTexture = new Texture(\"./textures/bullet_hole.png\", this.scene);\r\n\r\n        // Create a material with the bullet hole texture\r\n        \r\n        this.bulletHoleMaterial.roughness = 0.5;\r\n        this.bulletHoleMaterial.albedoTexture.hasAlpha = true;\r\n        this.bulletHoleMaterial.zOffset = -0.25;\r\n\r\n        //this.bulletHoleMaterial.zOffset = -0.25;\r\n        /* this.splatter = new PBRMaterial(\"greenSplatter\", this.scene);\r\n        this.splatter.roughness = 1;\r\n        this.splatter.albedoTexture = new Texture(\"textures/green.png\", this.scene);\r\n        this.splatter.albedoTexture.hasAlpha = true;\r\n*/\r\n      \r\n    \r\n}\r\n\r\ncreateMuzzleFlashParticleSystem(): void {\r\n    // Create particle system\r\n    this.muzzleFlashParticleSystem = new ParticleSystem(\"muzzleFlash\", 200, this.scene);\r\n    \r\n    // Set particle texture\r\n    const texture = new Texture(\"./textures/particles/star_01.png\", this.scene);\r\n    texture._parentContainer = this.gunMesh;\r\n    this.muzzleFlashParticleSystem.particleTexture = texture;\r\n    \r\n    // Set particle system properties\r\n    this.muzzleFlashParticleSystem.emitter = this.gunMesh; // Set emitter to gun mesh\r\n    this.muzzleFlashParticleSystem.minEmitBox = new Vector3(-0.3, -0.25, 3.2); \r\n    this.muzzleFlashParticleSystem.maxEmitBox = new Vector3(-0.3, -0.25, 3.2); \r\n      \r\n    \r\n    this.muzzleFlashParticleSystem.color1 = new Color4(0.8, 0.5, 0, 1); // Bright yellow-orange \r\n    this.muzzleFlashParticleSystem.color2 = new Color4(0.8, 0.5, 0, 1); \r\n    this.muzzleFlashParticleSystem.colorDead = new Color4(1, 0.5, 0, 1); \r\n    \r\n       \r\n    this.muzzleFlashParticleSystem.minSize = 1;\r\n    this.muzzleFlashParticleSystem.maxSize = 2; \r\n    this.muzzleFlashParticleSystem.minLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.maxLifeTime = 0.01; \r\n    this.muzzleFlashParticleSystem.emitRate = 25; // Adjust emission rate\r\n\r\n \r\n    \r\n    \r\n    this.muzzleFlashParticleSystem.minInitialRotation = 0;\r\n    this.muzzleFlashParticleSystem.maxInitialRotation = Math.PI * 2; // Full circle\r\n\r\n\r\n\r\n    this.muzzleFlashParticleSystem.start();\r\n    this.muzzleFlashParticleSystem.stop(); \r\n\r\n\r\n    \r\n}\r\n\r\n\r\n\r\n\r\ncontrolFireRate() {\r\n    if (!this.canFire) {\r\n        this.currentFireRate -= this.scene.getEngine().getDeltaTime();\r\n        \r\n        if (this.currentFireRate <= 0) {\r\n            this.canFire = true;\r\n            this.currentFireRate = this.fireRate;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","import { Scene, Engine, SceneLoader, Vector3, HemisphericLight, FreeCamera, Sound, Mesh, AbstractMesh, TransformNode, MeshBuilder, StandardMaterial, Texture, Color3, Material, Animation, Matrix, PBRMaterial, CubeTexture, Quaternion, Ray, EasingFunction, CubicEase, PhysicsImpostor, ColorGradient, Color4, Tags, CannonJSPlugin, SceneOptimizerOptions, SceneOptimizer, HardwareScalingOptimization, ScenePerformancePriority } from \"@babylonjs/core\";\r\nimport { AdvancedDynamicTexture, TextBlock, Button, Rectangle, Control, LinearGradient } from \"@babylonjs/gui\";\r\n\r\nimport \"@babylonjs/loaders\";\r\n\r\nimport { Level } from \"./Level\";\r\nimport { Weapon } from \"./Weapon\";\r\n\r\nimport { Enemy } from \"./Enemy\";\r\nimport { Player } from \"./Player\";\r\n\r\nimport { AmmoPickup } from \"./AmmoPickup\";\r\n\r\nimport { FirstAidPickup } from \"./FirstAidPickup\";\r\nimport { WeaponPickups } from \"./WeaponPickups\";\r\n\r\nimport { UI } from \"./UI\";\r\nimport { Mutant } from \"./Mutant\";\r\nimport { Warrok } from \"./Warrok\";\r\n\r\n\r\n\r\nimport { M60 } from \"./M60\";\r\nimport { Pistol } from \"./Pistol\";\r\nimport { Minigun } from \"./Minigun\";\r\n\r\nimport { TorchPowerup } from \"./TorchPowerup\";\r\n\r\nexport class FirstPersonController {\r\n    scene: Scene;\r\n    engine: Engine;\r\n    weapon!: Weapon;\r\n    inventory!: Weapon[];\r\n    currentWeaponIndex!: number;\r\n    camera!: FreeCamera;\r\n    level: Level;\r\n    isJumping!: boolean;\r\n    wantToJump!: boolean;\r\n    isMoving!: boolean;\r\n    //bulletHoleMaterial!: PBRMaterial;\r\n    isSprinting: boolean;\r\n\r\n    ui: UI;\r\n\r\n    enemies: Enemy[];\r\n    player: Player;\r\n\r\n    playerBox: any;\r\n    ground: any;\r\n\r\n    //ammoBoxSound: Sound;\r\n    //firstAidSound: Sound;\r\n    outOfBreathSound: Sound;\r\n    \r\n\r\n    jumpSpeed: number;\r\n    jumpHeight: number;\r\n    jumpPeak: number;\r\n\r\n    minigun!: Minigun;\r\n    pistol!: Pistol;\r\n    rifle!: Weapon;\r\n\r\n\r\n    ammopickup: AmmoPickup;\r\n    firstaid: FirstAidPickup;\r\n    weaponPickups: WeaponPickups;\r\n    lmg: M60;\r\n    torchPowerup: TorchPowerup;\r\n\r\n    canReload!: boolean;\r\n\r\n    isPaused!: boolean;\r\n    \r\n\r\n    constructor(private canvas: HTMLCanvasElement) {\r\n\r\n        \r\n        \r\n      this.engine = new Engine(this.canvas, true);\r\n     \r\n      this.level = new Level(this.engine, this);\r\n      this.scene = this.level.scene;\r\n      //this.scene.blockMaterialDirtyMechanism = true;\r\n      \r\n\r\n      this.canReload = true;\r\n      this.isPaused = false;\r\n\r\n   /*    const optimizerOptions = new SceneOptimizerOptions(\r\n        \r\n    );\r\n\r\n    optimizerOptions.addOptimization(new HardwareScalingOptimization(0,1));\r\n    \r\n    \r\n    SceneOptimizer.OptimizeAsync(this.scene, optimizerOptions); */\r\n    \r\n      \r\n       \r\n            this.outOfBreathSound = new Sound(\r\n                \"outOfBreath\",\r\n                \"./audio/player/outofbreath.mp3\",\r\n                this.scene,\r\n                null,\r\n                {\r\n                    //spatialSound:true,\r\n                    volume: 1,\r\n                    autoplay:false\r\n                });\r\n\r\n\r\n                \r\n\r\n      this.isSprinting = false;\r\n      this.isJumping = false;\r\n      this.isMoving = false;\r\n      this.jumpSpeed = 0.1; \r\n      this.jumpHeight = 2; \r\n      this.jumpPeak = 0; \r\n \r\n      this.enemies = [];\r\n      this.inventory = [];\r\n\r\n      this.ammopickup = this.level.ammopickup;\r\n      this.firstaid = this.level.firstaid;\r\n\r\n     \r\n      this.CreateController();\r\n      \r\n      this.CreateImpostors();\r\n      this.player = new Player(this.camera, this.scene, this);\r\n   \r\n\r\n      /* this.level.startWaveSystem(); */\r\n   \r\n\r\n\r\n      this.minigun = new Minigun(this.scene, this.camera, this.enemies, this.player, this.canvas);\r\n      this.pistol = new Pistol(this.scene, this.camera, this.enemies, this.player, this.canvas);\r\n      this.rifle = new Weapon(this.scene, this.camera, this.enemies, this.player, this.canvas);\r\n      this.lmg = new M60(this.scene, this.camera, this.enemies, this.player, this.canvas);\r\n\r\n      this.lmg.preloadMesh();\r\n      this.minigun.preloadMesh();\r\n      this.rifle.preloadMesh();\r\n\r\n      this.weapon = this.pistol;\r\n\r\n      this.inventory.push(this.weapon);\r\n      \r\n\r\n \r\n\r\n\r\n     /*  this.inventory.push(new Weapon(this.scene, this.camera, this.enemies));\r\n      this.inventory.push(new Pistol(this.scene, this.camera, this.enemies));\r\n      this.inventory.push(new Minigun(this.scene, this.camera, this.enemies)); */\r\n      this.currentWeaponIndex = 0;\r\n\r\n\r\n        // Preload meshes for all weapons in the inventory\r\n        this.inventory.forEach((weapon, index) => {\r\n            if(weapon !== this.weapon) {\r\n                weapon.preloadMesh();\r\n            }\r\n        });\r\n\r\n      \r\n      \r\n       \r\n\r\n     \r\n      this.weapon.CreateG();\r\n  \r\n  \r\n      this.setupInput();\r\n      this.loadFootsteps();\r\n  \r\n\r\n      //this.loadText();\r\n\r\n      this.ui = new UI(this.player, this.weapon, this.inventory, this.currentWeaponIndex, this.level);\r\n      this.ui.unpauseButton.onPointerClickObservable.add(() => {\r\n        this.togglePause();\r\n        \r\n    });\r\n\r\n      //this.switchWeapon(this.currentWeaponIndex);\r\n\r\n/*         \r\n        this.ammopickup.CreateAmmoPickup(new Vector3(95,0,-76));\r\n\r\n        \r\n        this.firstaid.CreateFirstAidPickup(new Vector3(100,0,-86)); */\r\n\r\n\r\n      this.weaponPickups = this.level.weaponPickups;\r\n    /*   this.weaponPickups.CreateMinigunPickup(new Vector3(90,0,-75));\r\n      this.weaponPickups.CreatePistolPickup(new Vector3(100,0,-75));\r\n      this.weaponPickups.CreateRiflePickup(new Vector3(110,0,-75));\r\n      this.weaponPickups.CreateLMGPickup(new Vector3(120,0,-75)); */\r\n\r\n\r\n      this.torchPowerup = new TorchPowerup(this.scene, this.camera);\r\n\r\n      this.torchPowerup.CreateTorchPowerup(new Vector3(-30, 0, 40));\r\n\r\n      \r\n\r\n      let isShooting = false;\r\n\r\nthis.scene.onPointerDown = (evt) => {\r\n    if (!this.engine.isPointerLock && evt.button === 0) {\r\n        this.engine.enterPointerlock();\r\n        Engine.audioEngine?.unlock();\r\n    } else if (evt.button === 0 && !this.player.isDead() && !this.weapon.isReloading) {\r\n        if (this.weapon.toggleAutomatic) {\r\n            isShooting = true;\r\n            this.canReload = false;\r\n            shootLoop();\r\n        } else {\r\n            shootOnce();\r\n        }\r\n    }\r\n};\r\n\r\nthis.scene.onPointerUp = (evt) => {\r\n    if (evt.button === 0) {\r\n        isShooting = false;\r\n        this.canReload =  true;\r\n    }\r\n};\r\n\r\nlet lastShotTime = 0;\r\n\r\n\r\n\r\nconst shootOnce = () => {\r\n    if (this.weapon.ammo > 0) {\r\n        this.weapon.shoot();\r\n       \r\n\r\n        if(this.weapon === this.minigun) { \r\n            \r\n\r\n            if(this.weapon.isReadying) {\r\n                this.weapon.animationGroups.forEach(function (animationGroup) {\r\n                    animationGroup.stop();\r\n                });\r\n\r\n                this.weapon.isReadying = false;\r\n\r\n            }\r\n\r\n                this.weapon.shootAnimation(this.weapon);\r\n            \r\n            this.minigun.muzzleAnimation(this.weapon); \r\n            \r\n        }\r\n\r\n\r\n        else {\r\n            this.weapon.shootAnimation(this.weapon);\r\n        }\r\n\r\n\r\n    } else {\r\n        this.weapon.emptySound.play();\r\n    }\r\n};\r\n\r\n\r\n\r\nconst shootLoop = () => {\r\n    const currentTime = performance.now(); \r\n    if (isShooting && this.weapon.toggleAutomatic) {\r\n        if (this.weapon.ammo > 0 && currentTime - lastShotTime >= this.weapon.fireRate) {\r\n            shootOnce();\r\n            lastShotTime = currentTime;\r\n        } else if (this.weapon.ammo <= 0) {\r\n            isShooting = false;\r\n            this.weapon.emptySound.play();\r\n        }\r\n    }\r\n    requestAnimationFrame(shootLoop);\r\n};\r\n\r\n\r\nrequestAnimationFrame(shootLoop);\r\n\r\n\r\n\r\n\r\n\r\nthis.scene.onDataLoadedObservable.addOnce(() => {\r\n    \r\n    this.camera.needMoveForGravity = true;\r\n    this.engine.hideLoadingUI();\r\n    this.level.startWaveSystem();\r\n});\r\n\r\n      \r\n      \r\n    this.scene.registerBeforeRender(() => {\r\n  \r\n        for (const enemy of this.enemies) {\r\n          \r\n            enemy.move(this.player); \r\n            \r\n        }\r\n\r\n \r\n       if(this.playerBox.position.y+1 > 1.56) {\r\n        this.camera.position.y = this.playerBox.position.y+1;\r\n       }\r\n\r\n       \r\n\r\n        this.playerBox.position.z = this.camera.position.z;\r\n        this.playerBox.position.x = this.camera.position.x;\r\n\r\n        \r\n\r\n        if(this.camera.position.y <= 1.56) {\r\n            this.isJumping = false;\r\n        }\r\n\r\n        if(this.playerBox.position.y < 0) {\r\n            this.playerBox.position.y = 0.57; // try reset to fix bug\r\n        }\r\n    });\r\n\r\n\r\n    \r\n\r\n      this.engine.runRenderLoop(() => {\r\n\r\n\r\n\r\n        //this.checkMeshesInFrustum();\r\n\r\n        //this.level.checkFrustumVisibility();\r\n    \r\n   \r\n\r\n        if (this.isPaused) {\r\n            this.ui.showPauseScreen();\r\n            return; \r\n        }\r\n   \r\n        this.player.updatePosition(this.camera);\r\n\r\n          \r\n\r\n           \r\n            this.ui.updateAmmoText();\r\n            this.ui.updatePlayerHP();\r\n            this.ui.updateStaminaText();\r\n            this.ui.updatePlayerScore();\r\n            this.ui.updateWaveNumber();\r\n            this.ui.updateWaveTimer();\r\n\r\n\r\n            if(this.player.health <= 0) {\r\n                this.camera.position.y = 0.3;\r\n\r\n                this.weapon.animationGroups.forEach(function (animationGroup) {\r\n                    animationGroup.stop();\r\n                });\r\n                 \r\n                this.camera.detachControl();\r\n                this.engine.exitPointerlock();\r\n                this.ui.createDeathScreen();\r\n            }\r\n\r\n\r\n\r\n            if(this.isSprinting && this.player.stamina > 0) {\r\n                this.camera.speed = this.player.sprintSpeed;\r\n            }\r\n            if(!this.isSprinting || this.player.stamina <=0 ) {\r\n                this.camera.speed = this.player.walkSpeed;\r\n            }\r\n\r\n        \r\n         \r\n        this.scene.render();\r\n        \r\n      });\r\n  \r\n  \r\n  \r\n      \r\n    }\r\n  \r\n  \r\n  \r\n    CreateController(): void {\r\n      const camera = new FreeCamera(\"camera\", new Vector3(-35, 15, 55), this.scene);\r\n      camera.setTarget(new Vector3(0,1.5,-2));\r\n      camera.attachControl();\r\n      camera.applyGravity = true;\r\n      camera.checkCollisions = true;\r\n      camera.ellipsoid = new Vector3(1, 0.75, 1);\r\n      camera.minZ = 0;\r\n  \r\n      camera.speed = 1.2;\r\n      camera.angularSensibility = 800;\r\n      \r\n      camera.keysUp.push(90);\r\n      camera.keysUp.push(87);\r\n\r\n      camera.keysDown.push(83);\r\n\r\n      camera.keysLeft.push(81);\r\n      camera.keysLeft.push(65);\r\n\r\n      camera.keysRight.push(68);\r\n        \r\n      camera.inertia = 0.1;\r\n\r\n\r\n\r\n     \r\n\r\n  \r\n      this.camera = camera;\r\n\r\n      \r\n     \r\n      camera.onCollide = (collidedMesh) => {\r\n        switch (collidedMesh.id) {\r\n            case 'ammoBox':\r\n                this.ammopickup.pickupSound.play();\r\n                this.weapon.reloadAmmo += 120;\r\n                this.weapon.reloadWeapon();\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'firstAid':\r\n                this.firstaid.pickupSound.play();\r\n                this.player.health = this.player.maxHealth;\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'minigunPickup':\r\n                this.weaponPickups.pickupSound.play();\r\n                if (!this.inventory.includes(this.minigun)) {\r\n                    this.inventory.push(this.minigun);\r\n                } else {\r\n                    this.minigun.reloadAmmo += 180;\r\n                }\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'pistolPickup':\r\n                this.weaponPickups.pickupSound.play();\r\n                if (!this.inventory.includes(this.pistol)) {\r\n                    this.inventory.push(this.pistol);\r\n                } else {\r\n                    this.pistol.reloadAmmo += 60;\r\n                }\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'riflePickup':\r\n                this.weaponPickups.pickupSound.play();\r\n                if (!this.inventory.includes(this.rifle)) {\r\n                    this.inventory.push(this.rifle);\r\n                } else {\r\n                    this.rifle.reloadAmmo += 60;\r\n                }\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'lmgPickup':\r\n                this.weaponPickups.pickupSound.play();\r\n                if (!this.inventory.includes(this.lmg)) {\r\n                    this.inventory.push(this.lmg);\r\n                } else {\r\n                    this.lmg.reloadAmmo += 120;\r\n                }\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'torchPowerup':\r\n                this.torchPowerup.pickupSound.play();\r\n                this.rifle.damage += 4;\r\n                this.pistol.damage += 2;\r\n                this.minigun.damage += 6;\r\n                this.lmg.damage += 6;\r\n    \r\n                this.player.score += this.level.torchPowerup.scoreValue;\r\n    \r\n                if (this.player.jumpingPower < 12) {\r\n                    this.player.jumpingPower += 1;\r\n                }\r\n    \r\n                if (this.player.staminaDecayRate > 2) {\r\n                    this.player.staminaDecayRate -= 1;\r\n                }\r\n    \r\n                if (this.player.staminaRegenRate < 10) {\r\n                    this.player.staminaRegenRate += 1;\r\n                }\r\n    \r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            case 'medalPowerup':\r\n                this.torchPowerup.pickupSound.play();\r\n                if (this.player.sprintSpeed < 7) {\r\n                    this.player.sprintSpeed += 0.25;\r\n                }\r\n    \r\n                this.player.score += this.level.medalPowerup.scoreValue;\r\n                collidedMesh.dispose();\r\n                break;\r\n    \r\n            default:\r\n                \r\n                break;\r\n        }\r\n    }\r\n    \r\n\r\n\r\n\r\n\r\n\r\n    \r\n      \r\n    \r\n\r\n      \r\n      }\r\n  \r\n      \r\n\r\n      \r\n     \r\n      \r\n        \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    setupInput(): void {\r\n\r\n        const pressedKeys: { [key: string]: boolean } = {\r\n            KeyW: false,\r\n            KeyA: false,\r\n            KeyS: false,\r\n            KeyD: false,\r\n            ShiftLeft: false,\r\n            ShiftRight: false\r\n        };\r\n\r\n\r\n\r\n         \r\n         document.addEventListener('keydown', (event) => {\r\n             if (event.code === 'KeyW' || event.code === 'KeyA' || event.code === 'KeyS' || event.code === 'KeyD') {\r\n                \r\n                 this.isMoving = true;\r\n                 pressedKeys[event.code] = true;\r\n             }\r\n\r\n             if ((event.code === 'ShiftLeft' || event.code === 'ShiftRight') && this.isMoving) {\r\n                event.preventDefault();\r\n                 this.isSprinting = true;\r\n                 if(this.player.stamina > 0) {\r\n                     this.camera.speed = this.player.sprintSpeed;\r\n                 }\r\n                 else {\r\n                     this.camera.speed = this.player.walkSpeed;\r\n                 }\r\n                 this.player.decayStamina();\r\n             }\r\n\r\n\r\n              \r\n                    switch (event.code) {\r\n                        case 'Digit1':\r\n                            event.preventDefault();\r\n                            this.switchWeaponByKey(0);\r\n                            break;\r\n                        case 'Digit2':\r\n                            event.preventDefault();\r\n                            this.switchWeaponByKey(1);\r\n                            break;\r\n                        case 'Digit3':\r\n                            event.preventDefault();\r\n                            this.switchWeaponByKey(2);\r\n                            break;\r\n                        case 'Digit4':\r\n                            event.preventDefault(); // default 4 on firefox\r\n                            this.switchWeaponByKey(3);\r\n                            break;\r\n\r\n                        case 'Digit9':\r\n                            event.preventDefault();\r\n                            this.toggleGodMode();\r\n                            break;\r\n\r\n\r\n                       /*  case 'Digit8': \r\n                            event.preventDefault();\r\n                            this.togglePause();\r\n                            break; */\r\n                    }\r\n         });\r\n\r\n         \r\n         document.addEventListener('keyup', (event) => {\r\n             if (event.code === 'KeyW' || event.code === 'KeyA' || event.code === 'KeyS' || event.code === 'KeyD') {\r\n                 \r\n                 pressedKeys[event.code] = false;\r\n                 if (!pressedKeys['KeyW'] && !pressedKeys['KeyA'] && !pressedKeys['KeyS'] && !pressedKeys['KeyD']) {\r\n                     this.isMoving = false;\r\n                 }\r\n             }  \r\n\r\n             if (event.code === 'ShiftLeft' || event.code === 'ShiftRight') {\r\n                 \r\n                 this.isSprinting = false;\r\n                 this.camera.speed = this.player.walkSpeed;\r\n                 this.player.regenStamina();\r\n             }\r\n         });\r\n\r\n\r\n\r\n     window.addEventListener('keydown', (event) => {\r\n      \r\n\r\n         if (event.code === 'Space' && !this.isJumping) {         \r\n                event.preventDefault();     \r\n                 this.jump();\r\n                 this.isJumping = true;\r\n         }\r\n        \r\n         if (event.code === 'KeyR') {\r\n             if (this.weapon.reloadAmmo > 0 && !this.weapon.isReloading && this.canReload) {\r\n                 this.weapon.reloadAnimation(this.weapon);\r\n                 this.weapon.reloadWeapon();\r\n                 \r\n                 this.weapon.reloadSound.play();\r\n             }\r\n         }\r\n        \r\n        if(event.code === 'KeyH') {\r\n            console.log(\"PLAYERBOX: \", this.playerBox.position.y);\r\n           \r\n            console.log(\"player x:\", this.camera.position.x);\r\n            console.log(\"player y:\", this.camera.position.y);\r\n            console.log(\"player z:\", this.camera.position.z);\r\n            \r\n        }\r\n\r\n        \r\n        \r\n        });\r\n\r\n    \r\n\r\n    \r\n\r\n\r\n        window.addEventListener('wheel', (event) => {\r\n            // Check if the event target is the canvas\r\n            if (event.target === this.canvas) {\r\n                // Prevent the default scrolling behavior\r\n                event.preventDefault();\r\n        \r\n                if (event.deltaY < 0) {\r\n                    this.cycleWeapon(1);\r\n                } else if (event.deltaY > 0) {\r\n                    this.cycleWeapon(-1);\r\n                }\r\n            }\r\n        }, { passive: false }); \r\n \r\n\r\n       \r\n    }\r\n    \r\n    \r\n    jump(): void {\r\n       \r\n\r\n        if(!this.isJumping && !this.player.isDead()) {\r\n            this.playerBox.physicsImpostor.applyImpulse(new Vector3(0,this.player.jumpingPower,0), this.playerBox.getAbsolutePosition());\r\n            \r\n        }\r\n    }\r\n    \r\n\r\n\r\n    \r\n\r\n        loadFootsteps(): void {\r\n\r\n            const footstepsSound = new Sound(\r\n                \"footstepsSound\",\r\n                \"./audio/footsteps.mp3\",\r\n                this.scene,\r\n                null,\r\n                {\r\n                    volume: 1, \r\n                    loop: true \r\n                }\r\n            );\r\n        \r\n            const startFootsteps = () => {\r\n                if (!footstepsSound.isPlaying) {\r\n                    footstepsSound.play();\r\n                }\r\n            };\r\n        \r\n           \r\n            const stopFootsteps = () => {\r\n                if (footstepsSound.isPlaying) {\r\n                    footstepsSound.stop();\r\n                }\r\n            };\r\n        \r\n            \r\n            this.scene.onBeforeRenderObservable.add(() => {\r\n                if (this.isMoving && !this.player.isDead() && !this.isJumping) {\r\n                    startFootsteps();\r\n                  \r\n                } else {\r\n                    stopFootsteps();\r\n                 \r\n                }\r\n            });\r\n\r\n\r\n           \r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        loadBreathing() {\r\n            const outOfBreath = new Sound(\r\n                \"firstAidPickup\",\r\n                \"./audio/player/outofbreath.mp3\",\r\n                this.scene,\r\n                null,\r\n                {\r\n                    spatialSound:true,\r\n                    volume: 1,\r\n                    autoplay:false\r\n                });\r\n\r\n                if(this.player.stamina == 0) {\r\n                    outOfBreath.play();\r\n                }\r\n\r\n        }\r\n\r\n\r\n    \r\n\r\n        CreateImpostors(): void {\r\n\r\n                       \r\n                this.playerBox = MeshBuilder.CreateSphere(\"playerBox\", { diameter: 1}, this.scene);\r\n                this.playerBox.position.x = this.camera.position.x; \r\n\r\n                this.playerBox.position.z = this.camera.position.z;\r\n                this.playerBox.position.y = 0.055+0.5;\r\n\r\n                this.playerBox.isVisible = false;\r\n               \r\n                this.playerBox.isPickable = false;\r\n                \r\n               \r\n                this.playerBox.physicsImpostor = new PhysicsImpostor(\r\n                    this.playerBox,\r\n                    PhysicsImpostor.SphereImpostor,\r\n                    { mass: 1, restitution: 0, friction: 0 },\r\n                    this.scene\r\n                );\r\n\r\n\r\n                 this.playerBox.physicsImpostor.registerOnPhysicsCollide(\r\n                    this.ground.physicsImpostor,\r\n                    this.isNotJumping\r\n                ); \r\n        } \r\n\r\n\r\n\r\n\r\n        isNotJumping(): void {\r\n            this.isJumping = false;\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n        cycleWeapon(direction: number): void {\r\n           \r\n            if (this.inventory.length === 1) {\r\n                return;\r\n            }\r\n        \r\n         \r\n            this.currentWeaponIndex += direction;\r\n        \r\n           \r\n            if (this.currentWeaponIndex < 0) {\r\n                this.currentWeaponIndex = this.inventory.length - 1;\r\n            } else if (this.currentWeaponIndex >= this.inventory.length) {\r\n                this.currentWeaponIndex = 0;\r\n            }\r\n        \r\n           \r\n          \r\n            this.switchWeapon(this.currentWeaponIndex);\r\n        }\r\n        \r\n        switchWeapon(index: number): void {\r\n          \r\n            if (index >= 0 && index < this.inventory.length) {\r\n              \r\n                if (this.weapon && this.weapon.isMeshCreated && this.weapon.gunMesh) {\r\n                    this.weapon.gunMesh.setEnabled(false);\r\n                }\r\n                \r\n              \r\n                this.weapon = this.inventory[index];\r\n                this.weapon.readyAnimation(this.weapon);\r\n                this.weapon.readySfx();\r\n\r\n                this.ui.weapon = this.weapon;\r\n                this.ui.updateAmmoText();\r\n        \r\n               \r\n                if (!this.weapon.isMeshCreated) {\r\n                    this.weapon.CreateG(); \r\n                }\r\n        \r\n             \r\n                if (this.weapon && this.weapon.isMeshCreated && this.weapon.gunMesh) {\r\n                    this.weapon.gunMesh.setEnabled(true);\r\n                }\r\n\r\n\r\n                this.currentWeaponIndex = index;\r\n        \r\n            }\r\n        \r\n        \r\n        }\r\n        \r\n\r\n        applyShockwave() {\r\n            const originalCameraSpeed = this.camera.speed;\r\n            this.camera.speed = this.camera.speed*0.5;\r\n            setTimeout(() => {\r\n                this.camera.speed = originalCameraSpeed;\r\n                /* this.camera.speed = originalCameraSpeed; */\r\n            }, 6000);\r\n\r\n        }\r\n\r\n\r\n\r\n        switchWeaponByKey(index: number): void {\r\n            if(index === this.currentWeaponIndex) { return; }\r\n\r\n            if (index >= 0 && index < this.inventory.length /* && index !== this.currentWeaponIndex */) {\r\n                this.switchWeapon(index);\r\n            }\r\n        }\r\n\r\n\r\n\r\n\r\n        toggleGodMode() {\r\n            this.player.maxHealth = 9000;\r\n            this.player.health = 9000;\r\n\r\n            this.player.staminaDecayRate = 0;\r\n            this.player.staminaRegenRate = 20;\r\n\r\n            this.player.sprintSpeed = 7;\r\n            this.player.jumpingPower = 12;\r\n\r\n            /* this.pistol.damage = 1000;\r\n            this.rifle.damage = 1000;\r\n            this.lmg.damage = 1000;\r\n            this.minigun.damage = 1000; */\r\n\r\n\r\n            this.inventory.push(this.rifle);\r\n            this.inventory.push(this.lmg);\r\n            this.inventory.push(this.minigun);\r\n\r\n            \r\n        }\r\n\r\n\r\n        togglePause(): void {\r\n            \r\n    \r\n            if (this.isPaused) {\r\n\r\n                this.ui.showPauseScreen();\r\n               \r\n                this.camera.detachControl();\r\n  \r\n                \r\n\r\n\r\n            } else {\r\n                this.ui.hidePauseScreen();\r\n               \r\n                this.camera.attachControl();\r\n                \r\n            }\r\n        }\r\n\r\n\r\n\r\n\r\n        \r\n    checkMeshesInFrustum(): void {\r\n       \r\n        this.scene.meshes.forEach((mesh) => {\r\n           \r\n            if (!this.camera.isInFrustum(mesh)) {\r\n                mesh.isVisible = false;\r\n            } else {\r\n                mesh.isVisible = true;\r\n            }\r\n        });\r\n    }\r\n\r\n}","import { FirstPersonController } from \"./FirstPersonController\";\r\n\r\n// Main menu class definition\r\nexport class MainMenu {\r\n    private canvas: HTMLCanvasElement;\r\n    private startButton!: HTMLButtonElement;\r\n  \r\n    constructor(canvas: HTMLCanvasElement) {\r\n      this.canvas = canvas;\r\n      this.createUI();\r\n      this.setBackground();\r\n    }\r\n  \r\n    private createUI() {\r\n      const startButton = document.createElement('button');\r\n      startButton.innerText = 'Jouer';\r\n      startButton.style.position = 'absolute';\r\n      startButton.style.top = '50%';\r\n      startButton.style.left = '50%';\r\n      startButton.style.transform = 'translate(-50%, -50%)';\r\n      startButton.style.padding = '10px 20px';\r\n      startButton.style.fontSize = '16px';\r\n      startButton.style.backgroundColor = '#4CAF50';\r\n      startButton.style.color = 'white';\r\n      startButton.style.border = 'none';\r\n      startButton.style.borderRadius = '5px';\r\n      startButton.style.cursor = 'pointer';\r\n      \r\n      startButton.addEventListener('click', () => {\r\n        this.startGame();\r\n      });\r\n  \r\n     \r\n      document.body.appendChild(startButton);\r\n  \r\n      this.startButton = startButton;\r\n    }\r\n  \r\n    private setBackground() {\r\n      document.body.style.backgroundImage = 'url(\"textures/olympicBackground.jpg\")';\r\n      document.body.style.backgroundSize = 'cover';\r\n      document.body.style.backgroundPosition = 'center';\r\n      document.body.style.backgroundRepeat = 'no-repeat';\r\n      document.body.style.height = '100vh'; // Ensures the background covers the entire viewport\r\n      document.body.style.margin = '0';\r\n    }\r\n  \r\n    private startGame() {\r\n      // Remove the start button\r\n      this.startButton.remove();\r\n      // Initialize FirstPersonController\r\n      new FirstPersonController(this.canvas);\r\n    }\r\n}\r\n","import { render } from \"./Savior.vue?vue&type=template&id=036e46e7&scoped=true&ts=true\"\nimport script from \"./Savior.vue?vue&type=script&lang=ts\"\nexport * from \"./Savior.vue?vue&type=script&lang=ts\"\n\nimport \"./Savior.vue?vue&type=style&index=0&id=036e46e7&scoped=true&lang=css\"\n\nimport exportComponent from \"../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-036e46e7\"]])\n\nexport default __exports__","import { render } from \"./App.vue?vue&type=template&id=28f57374&ts=true\"\nimport script from \"./App.vue?vue&type=script&lang=ts\"\nexport * from \"./App.vue?vue&type=script&lang=ts\"\n\nimport \"./App.vue?vue&type=style&index=0&id=28f57374&lang=css\"\n\nimport exportComponent from \"../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { createApp } from 'vue'\nimport App from './App.vue'\n\ncreateApp(App).mount('#app')\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/testing/\";","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t524: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkb101\"] = self[\"webpackChunkb101\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [504], function() { return __webpack_require__(2236); })\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["render","_ctx","_cache","$props","$setup","$data","$options","_component_Savior","_hoisted_1","_hoisted_3","ref","_hoisted_4","scene","level","this","isSpellCasting","health","name","mesh","rootMesh","isDead","appliesDot","id","Enemy","enemyCount","states","isAttacking","isReacting","generateRandomPosition","position","Promise","ImportMeshAsync","meshes","animationGroups","scaling","checkCollisions","AddTagsTo","stop","play","start","onAnimationEndObservable","addOnce","pause","console","log","DESTROYED","FOLLOWING","ATTACKING","runAnimation","idleAnimation","player","distanceFromPlayer","subtract","length","attackPlayer","aggroRange","followPlayer","randomPositionX","Math","floor","random","randomPositionZ","randPosition","direction","normalize","alpha","atan2","x","z","rotation","y","collider","moveWithCollisions","multiplyByFloats","runSpeed","attackTimer","attackInterval","attackSpeed","attackOnce","clearInterval","isPlayerInRange","max","damage","hasDot","applyDot","punchAnimation","attackSound","setInterval","setTimeout","dispose","scoreValue","volume","autoplay","createBoxCollider","clones","duplicate","instances","mutantAssetContainer","rotationQuaternion","clone","isVisible","death","idle","punch","run","shot","uppercut","walk","walkSpeed","registerBeforeRender","CreateBox","height","width","depth","visibility","isPickable","remove","isPlaying","forEach","animationGroup","isAnyAnimationPlaying","some","sourceAnimationGroups","targetMesh","map","sourceGroup","newGroup","targetedAnimations","targetedAnim","newAnim","animation","addTargetedAnimation","container","entries","instantiateModelsToScene","undefined","doNotInstantiate","rootNodes","getChildMeshes","shadowGen","addShadowCaster","setEnabled","node","pickupSound","glowLayer","intensity","camera","isInFrustum","warrokAssetContainer","transformNode","skeletonZombieAssetContainer","shockWaveSound","shockWaveCastSound","spatialSound","isVulnerable","bossAssetContainer","spellcast","speedRatio","loadParticleSystem","startSpellcastingInterval","startAddGeneration","attachToMesh","stopWaveSystem","generateAddsInterval","firstPersonController","ui","createWinScreen","detachControl","spellParticles","applyShockwave","particleSystem","particleTexture","emitter","minEmitBox","maxEmitBox","createSphereEmitter","color1","color2","colorDead","minSize","maxSize","minLifeTime","maxLifeTime","minInitialRotation","PI","maxInitialRotation","emitRate","blendMode","BLENDMODE_ONEONE","spellInterval","spellAnimation","glowInterval","removeGlowEffect","addGlowEffect","addIncludedOnlyMesh","glowColor","number","minX","maxX","minZ","maxZ","i","randomX","randomZ","enemyTypes","Mutant","SkeletonZombie","Warrok","EnemyClass","enemy","CreateMonster","enemies","push","GENERATE_ADDS_INTERVAL","generateAdds","sphereCollider","CreateSphere","diameter","glowMaterial","emissiveColor","material","setParent","parent","CreateMutant","CreateWarrok","CreateSkeletonZombie","CreateBoss","LoadAssetContainerAsync","addAllToScene","engine","CreateScene","waveNumber","nextWaveTime","displayLoadingUI","CreateEnvironment","CreateImpostors","createWall","createHWall","weaponPickups","WeaponPickups","ammopickup","AmmoPickup","firstaid","FirstAidPickup","torchPowerup","TorchPowerup","medalPowerup","MedalPowerup","Instances","envTex","CreateFromPrefilteredData","environmentTexture","createDefaultSkybox","environmentIntensity","hemi","light","shadowEnabled","autoUpdateExtends","autoCalcShadowZBounds","useBlurCloseExponentialShadowMap","useKernelBlur","blurKernel","blurScale","enablePhysics","collisionsEnabled","pbr","albedoTexture","uScale","vScale","bumpTexture","invertNormalMapX","invertNormalMapY","metallicTexture","_useAmbientOcclusionFromMetallicTextureRed","useRoughnessFromMetallicTextureGreen","useMetallnessFromMetallicTextureBlue","receiveShadows","ground","CreateGround","groundMaterial","CreateAsphalt","physicsImpostor","BoxImpostor","mass","restitution","loop","inventory","rifle","CreateRiflePickup","lmg","CreateLMGPickup","minigun","CreateMinigunPickup","mutant","warrok","skeletonZombie","boss","Boss","waveIntervalId","generateEnemies","startPickupGeneration","minY","maxY","CreateAmmoPickup","CreateFirstAidPickup","CreateTorchPowerup","CreateMedalPowerup","wallWidth","wallHeight","wallDepth","wallPosition","wall","wallMaterial","diffuseColor","friction","customLight","lightGizmo","scaleRatio","dummyMesh","attachedMesh","gizmoManager","positionGizmoEnabled","rotationGizmoEnabled","usePointerToAttachGizmos","canvas","isFiring","isReloading","isReadying","ammo","reloadAmmo","loadBulletholes","fireRate","isShootingAnimationPlaying","gunMeshChild","renderingGroupId","gunMesh","set","CreateCrosshair","shootSound","emptySound","reloadSound","readySound","createMuzzleFlashParticleSystem","isMeshCreated","size","plane","CreatePlane","texture","diffuseTexture","White","opacityTexture","transparencyMode","MATERIAL_ALPHABLEND","hasAlpha","gun","muzzleFlashParticleSystem","deviationAngle","deviationAmount","deviationVector","cos","sin","ray","getForwardRay","add","createPickingRay","clientWidth","clientHeight","raycastHit","pickWithRay","hit","MatchesQuery","pickedMesh","getEnemyFromMesh","playShotAnimation","score","playDeathAnimation","index","indexOf","splice","indexFPS","CreateDecal","pickedPoint","normal","getNormal","bulletHoleMaterial","remainingAmmo","reloadAmount","min","shotAnimation","deathAnimation","zOffset","roughness","_parentContainer","CreateG","maxHealth","stamina","maxStamina","jumpingPower","staminaRegenRate","staminaDecayRate","sprintSpeed","outOfBreath","duration","glowOverlay","document","createElement","body","appendChild","removeChild","damagePerSecond","dotTimer","originalWalkSpeed","originalSprintSpeed","playerBox","applyImpulse","getAbsolutePosition","isRegenerating","isDecaying","regenInterval","decayInterval","weapon","currentWeaponIndex","showDeathScreen","showWinScreen","loadText","createPauseUI","advancedTexture","CreateFullscreenUI","ammoContainer","background","cornerRadius","thickness","color","horizontalAlignment","HORIZONTAL_ALIGNMENT_LEFT","verticalAlignment","VERTICAL_ALIGNMENT_TOP","top","left","addControl","ammoTextBlock","fontFamily","fontWeight","fontSize","updateAmmoText","healthContainer","healthBlock","updatePlayerHP","staminaBar","shadowBlur","shadowOffsetX","shadowOffsetY","shadowColor","updateStaminaText","scoreContainer","scoreBlock","text","textHorizontalAlignment","textVerticalAlignment","waveBlock","waveTimeBlock","pauseMenu","pauseText","unpauseButton","CreateSimpleButton","VERTICAL_ALIGNMENT_BOTTOM","toString","healthBar","healthPercentage","red","green","staminaPercentage","deathScreen","HORIZONTAL_ALIGNMENT_CENTER","VERTICAL_ALIGNMENT_CENTER","youDiedText","scoreText","restartButton","onPointerUpObservable","removeControl","location","reload","winScreen","youWonText","canFire","currentFireRate","toggleAutomatic","rayDirection","getEngine","getDeltaTime","Weapon","rotate","Up","Level","canReload","isPaused","outOfBreathSound","isSprinting","isJumping","isMoving","jumpSpeed","jumpHeight","jumpPeak","CreateController","Player","Minigun","pistol","Pistol","M60","preloadMesh","setupInput","loadFootsteps","UI","onPointerClickObservable","togglePause","isShooting","onPointerDown","evt","isPointerLock","button","shootLoop","shootOnce","enterPointerlock","audioEngine","unlock","onPointerUp","lastShotTime","shoot","shootAnimation","muzzleAnimation","currentTime","performance","now","requestAnimationFrame","onDataLoadedObservable","needMoveForGravity","hideLoadingUI","startWaveSystem","move","runRenderLoop","showPauseScreen","updatePosition","updatePlayerScore","updateWaveNumber","updateWaveTimer","exitPointerlock","createDeathScreen","speed","setTarget","attachControl","applyGravity","ellipsoid","angularSensibility","keysUp","keysDown","keysLeft","keysRight","inertia","onCollide","collidedMesh","reloadWeapon","includes","pressedKeys","KeyW","KeyA","KeyS","KeyD","ShiftLeft","ShiftRight","addEventListener","event","code","preventDefault","decayStamina","switchWeaponByKey","toggleGodMode","regenStamina","window","jump","reloadAnimation","target","deltaY","cycleWeapon","passive","footstepsSound","startFootsteps","stopFootsteps","onBeforeRenderObservable","SphereImpostor","registerOnPhysicsCollide","isNotJumping","switchWeapon","readyAnimation","readySfx","originalCameraSpeed","hidePauseScreen","createUI","setBackground","startButton","innerText","style","transform","padding","backgroundColor","border","borderRadius","cursor","startGame","backgroundImage","backgroundSize","backgroundPosition","backgroundRepeat","margin","FirstPersonController","mounted","$refs","MainMenu","__exports__","components","Savior","App","mount","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","deferred","O","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","Object","keys","every","key","r","d","definition","o","defineProperty","enumerable","get","g","globalThis","Function","e","obj","prop","prototype","hasOwnProperty","call","p","b","baseURI","self","href","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","data","moreModules","runtime","chunkLoadingGlobal","bind","__webpack_exports__"],"sourceRoot":""}